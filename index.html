<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta charset="utf-8" />
<meta name="generator" content="Docutils 0.21.2: https://docutils.sourceforge.io/" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Well-founded recursion in Rocq</title>
<script type="text/javascript" defer src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.min.js?config=TeX-AMS_CHTML"></script>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<script>
    // Resolve backreferences
    document.addEventListener("DOMContentLoaded", function() {
        var references = document.querySelectorAll([
           ".alectryon-io .alectryon-extra-goals",
           ".alectryon-io .alectryon-goal",
           ".alectryon-io .alectryon-goals",
           ".alectryon-io .alectryon-output",
           ".alectryon-io .goal-conclusion",
           ".alectryon-io .goal-hyps",
           ".alectryon-io .goal-hyps > span"].join(", "));
        document.querySelectorAll('.alectryon-io q').forEach(function (q) {
            q.replaceWith(references[parseInt(q.innerText, 16)].cloneNode(true)) });
    });

    // Add checkboxes
    document.addEventListener("DOMContentLoaded", function() {
        var input = document.createElement("input");
        input.type = "checkbox";
        input.style = "display: none";

        input.className = "alectryon-extra-goal-toggle";
        document.querySelectorAll('.alectryon-io label.goal-separator').forEach(function(lbl, idx) {
            var goal = lbl.parentNode, box = input.cloneNode(true);
            lbl.htmlFor = box.id = "alectryon-hyps-chk" + idx;
            goal.parentNode.insertBefore(box, goal);
        });

        input.className = "alectryon-toggle";
        document.querySelectorAll('.alectryon-io .alectryon-output').forEach(function(div, idx) {
            var box = input.cloneNode(true), lbl = div.previousSibling;
            box.checked = div.classList.contains("a:show");
            if (lbl && lbl.tagName == "LABEL") {
                lbl.htmlFor = box.id = "alectryon-output-chk" + idx;
            }
            div.parentNode.insertBefore(box, lbl || div);
        });
    });
</script>
</head>
<body>
<div class="alectryon-root alectryon-centered alectryon-minified"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.20.0+0.20.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><main id="well-founded-recursion-in-rocq">
<h1 class="title">Well-founded recursion in Rocq</h1>

<pre class="alectryon-io highlight"><!-- Generator: Alectryon --></pre><style>
  .highlight.coq { background-color: #eeeeec; }

  /* hide bubbles */
  .alectryon-io label.alectryon-input       { padding-right: 0; }
  .alectryon-io label.alectryon-input:after { display: none; }
</style><p style="text-align: center; font-style: oblique;">Gijs Pennings, May 2025</p><p>Rocq requires that all functions terminate.
That is why, by default, only structurally recursive functions are allowed: functions that recur on structural subterms of the decreasing argument.
However, not all functions are structurally recursive.
A common solution is well-founded recursion, where arguments decrease with respect to a well-founded relation.
Several plugins support well-founded recursion, and in this tutorial we compare different methods through concrete examples.
This extends a paper by <a class="reference internal" href="#leroy-2024">Leroy (2024)</a>.</p>
<p>Proving properties of functions defined using well-founded recursion requires well-founded induction. Hence, this technique is introduced in the <a class="reference internal" href="#induction">first section</a>.
In the <a class="reference internal" href="#well-founded-recursion">next section</a>, we perform well-founded recursion using various methods on a simple example: Euclid's algorithm.
Then, in the <a class="reference internal" href="#quicksort">following section</a>, we use our preferred method to implement and verify quicksort.
In the <a class="reference internal" href="#rebalancing-binary-search-trees">last section</a>, we consider an algorithm on trees that requires a more specialized well-founded relation.</p>
<p>This tutorial was built using <a class="reference external" href="https://github.com/cpitclaudel/alectryon">Alectryon</a>.
To step through the proofs, use Ctrl and the arrow keys. For this purpose, the <em>floating</em> style (selectable from the top banner) offers the best readability.
The <a class="reference external" href="tutorial.v">source file</a> is also available.</p>
<!-- We assume familiarity with basic data structures and algorithms. -->
<section id="induction">
<h2>Induction</h2>
<p>Before we delve into recursive functions, we will first introduce some advanced forms of induction.
We illustrate this with a toy problem: the sum of the first <span class="math">\(k\)</span> odd numbers is equal to <span class="math">\(k^2\)</span>. We compute this sum as follows.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">sum_odd</span> (<span class="nv">k</span> : nat) : nat :=
  <span class="kr">match</span> k <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; <span class="mi">0</span>
  | S k&#39; =&gt; (<span class="mi">2</span>*k&#39; + <span class="mi">1</span>) + sum_odd k&#39;
  <span class="kr">end</span>.</span></span></pre><section id="refresher-weak-induction">
<h3>Refresher: (weak) induction</h3>
<p>In Rocq, we carry out induction using the eponymous <code class="highlight coq"><span class="nb">induction</span></code> tactic. It behaves like <code class="highlight coq"><span class="nb">destruct</span></code>, which performs a case analysis by generating a subgoal for each constructor of the inductive type. In addition, <code class="highlight coq"><span class="nb">induction</span></code> also introduces induction hypotheses.
Specifically, it applies an <em>induction principle</em>, by default the one that was automatically generated when the inductive type was declared.
Recall that for <code class="highlight coq"><span class="n">nat</span></code>, the default induction principle is:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Check</span> nat_ind.</label><small class="alectryon-output a:show"><div><div class="alectryon-messages"><blockquote class="alectryon-message">nat_ind
     : <span class="kr">forall</span> <span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>,
       P <span class="mi">0</span> -&gt;
       (<span class="kr">forall</span> <span class="nv">n</span> : nat, P n -&gt; P (S n)) -&gt;
       <span class="kr">forall</span> <span class="nv">n</span> : nat, P n</blockquote></div></div></small></span></pre><p>In plain language, it states that if some predicate <span class="math">\(P\)</span> holds for <span class="math">\(0\)</span>, and if it holds for <span class="math">\(n+1\)</span> given that it holds for <span class="math">\(n\)</span>, then <span class="math">\(P\)</span> holds for all natural numbers.</p>
<p>Let's apply induction to a simple example.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">sum_odd_eq_square</span> : <span class="kr">forall</span> <span class="nv">k</span>, sum_odd k = k*k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">k</span> : nat, sum_odd k = k * k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">induction</span> k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_odd <span class="mi">0</span> = <span class="mi">0</span> * <span class="mi">0</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>k</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHk</var><span class="hyp-type"><b>: </b><span>sum_odd k = k * k</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">sum_odd (S k) = S k * S k</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>8</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>c</q><span class="goal-separator"><hr></span><q>f</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>c</q><span class="goal-separator"><hr></span><div class="goal-conclusion">k + (k + <span class="mi">0</span>) + <span class="mi">1</span> + sum_odd k = S (k + k * S k)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> IHk.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>c</q><span class="goal-separator"><hr></span><div class="goal-conclusion">k + (k + <span class="mi">0</span>) + <span class="mi">1</span> + k * k = S (k + k * S k)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">ring</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>The two bullets correspond to the two premises of the induction principle: the <em>base case</em> and <em>step case</em>, respectively. At <code class="highlight coq"><span class="nb">rewrite</span> <span class="n">IHk</span></code>, we use the induction hypothesis.</p>
<p>Instead of <code class="highlight coq"><span class="nb">induction</span> <span class="n">k</span></code>, we could also write <code class="highlight coq"><span class="nb">induction</span> <span class="n">k</span> <span class="nb">using</span> <span class="n">nat_ind</span></code>, specifying the induction principle explicitly. Actually, we can even apply it manually:</p>
<!-- You may need to provide P explicitly. -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">k</span>, sum_odd k = k*k.</label><small class="alectryon-output"><div><q>2</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><q>5</q><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> nat_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>8</q><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
sum_odd n = n * n -&gt; sum_odd (S n) = S n * S n</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><q>10</q><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><q>22</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>sum_odd n = n * n</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_odd (S n) = S n * S n</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>29</q><span class="goal-separator"><hr></span><div class="goal-conclusion">n + (n + <span class="mi">0</span>) + <span class="mi">1</span> + sum_odd n = S (n + n * S n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>29</q><span class="goal-separator"><hr></span><div class="goal-conclusion">n + (n + <span class="mi">0</span>) + <span class="mi">1</span> + n * n = S (n + n * S n)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">ring</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></section>
<section id="strong-induction">
<h3>Strong induction</h3>
<p>We can use other induction principles as well.
One option is <em>strong induction</em>.
Compared to 'weak' induction as used above, it employs a stronger hypothesis: we prove that <span class="math">\(P\ n\)</span> under the assumption that <span class="math">\(P\ m\)</span> for all <span class="math">\(m &lt; n\)</span>. By contrast, weak induction essentially only assumes that <span class="math">\(P\ (n-1)\)</span>.</p>
<!-- strong = complete = course-of-values -->
<p>Strong induction on natural numbers is formalized by the following theorem.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Theorem</span> <span class="nf">strong_ind_nat</span> :
  <span class="kr">forall</span> <span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>,
    (<span class="kr">forall</span> <span class="nv">n</span>, (<span class="kr">forall</span> <span class="nv">m</span>, m &lt; n -&gt; P m) -&gt; P n) -&gt;
    <span class="kr">forall</span> <span class="nv">n</span>, P n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>,
(<span class="kr">forall</span> <span class="nv">n</span> : nat, (<span class="kr">forall</span> <span class="nv">m</span> : nat, m &lt; n -&gt; P m) -&gt; P n) -&gt;
<span class="kr">forall</span> <span class="nv">n</span> : nat, P n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>36</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>P</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat,
(<span class="kr">forall</span> <span class="nv">m</span> : nat, m &lt; n -&gt; P m) -&gt; P n</span></span></span><br><q>2a</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* We generalize the goal to strengthen the hypothesis! *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">enough</span> (<span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, b &lt;= a -&gt; P b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>3e</q><br><q>3f</q><br><q>2a</q><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : nat, b &lt;= a -&gt; P b</span></span></span><br></div><span class="goal-separator"><hr></span><q>40</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>3d</q><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : nat, b &lt;= a -&gt; P b</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>43</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> H0 <span class="kr">with</span> n.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>44</q><span class="goal-separator"><hr></span><div class="goal-conclusion">n &lt;= n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3d</q><span class="goal-separator"><hr></span><q>48</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">induction</span> a;
    <span class="nb">intros</span>;
    <span class="nb">apply</span> H;
    <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>3e</q><br><q>3f</q><br><span><var>n, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>b &lt;= <span class="mi">0</span></span></span></span><br><span><var>m</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>m &lt; b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P m</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>3e</q><br><q>3f</q><br><span><var>n, a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>IHa</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">b</span> : nat, b &lt;= a -&gt; P b</span></span></span><br><span><var>b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>b &lt;= S a</span></span></span><br><q>58</q><br><q>59</q><br></div><label class="goal-separator"><hr></label><q>5a</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>54</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.  <span class="c">(* contradiction *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5d</q><span class="goal-separator"><hr></span><q>5a</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> IHa.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>5d</q><span class="goal-separator"><hr></span><div class="goal-conclusion">m &lt;= a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Note that we can prove the strong induction principle using weak induction! (It is also possible and easy to prove the converse.)
This means that strong induction is exactly as powerful as weak induction, even if their names suggest otherwise; 'strong' only refers to the induction hypothesis.</p>
<!-- Note strong induction does not require separate base cases. -->
<p>We can again prove <code class="highlight coq"><span class="n">sum_odd_eq_square</span></code>, now using our strong induction principle.
It is not necessary to use strong induction here, but it serves as an example of how to use an alternative induction principle.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">k</span>, sum_odd k = k*k.</label><q>1d</q><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><q>5</q><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">induction</span> k <span class="nb">using</span> strong_ind_nat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>d</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : nat, m &lt; k -&gt; sum_odd m = m * m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">sum_odd k = k * k</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">destruct</span> k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : nat, m &lt; <span class="mi">0</span> -&gt; sum_odd m = m * m</span></span></span><br></div><span class="goal-separator"><hr></span><q>9</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>d</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : nat, m &lt; S k -&gt; sum_odd m = m * m</span></span></span><br></div><label class="goal-separator"><hr></label><q>f</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>73</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>78</q><span class="goal-separator"><hr></span><q>f</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>78</q><span class="goal-separator"><hr></span><q>18</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> H; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre></section>
<section id="well-founded-induction">
<h3>Well-founded induction</h3>
<p>Fundamentally, strong induction works because the natural numbers are well-ordered, meaning that every set of natural numbers has a least element. Hence, every 'chain of reasoning' reaches a base case, typically 0.
By contrast, the integers (with the usual ordering) are not well-ordered: <span class="math">\(\mathbb Z\)</span> has no least element, so there is no starting point for reasoning. In fact, there is an infinite descending chain, namely -1, -2, -3, etc.</p>
<p>The idea of strong induction can be generalized to any type equipped with a <em>well-founded relation</em>, i.e., a relation with no infinite descending chains.
Equivalently, every element must be <em>accessible</em>: there is a finite path of smaller elements leading to a least element.
This form of induction is known as <em>well-founded induction</em>.</p>
<!-- a.k.a. transfinite induction -->
<p>We define the notions of accessibility and well-foundedness in line with the <a class="reference external" href="https://rocq-prover.org/doc/V8.20.1/stdlib/Coq.Init.Wf.html">standard library</a>:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">WfInd</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">A</span> : <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">R</span> : A -&gt; A -&gt; <span class="kt">Prop</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">Acc</span> (<span class="nv">x</span> : A) : <span class="kt">Prop</span> :=
  Acc_intro : (<span class="kr">forall</span> <span class="nv">y</span>, R y x -&gt; Acc y) -&gt; Acc x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">well_founded</span> : <span class="kt">Prop</span> := <span class="kr">forall</span> <span class="nv">a</span>, Acc a.</span></span></pre><p>Now, we can state and prove the well-founded induction principle.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Theorem</span> <span class="nf">well_founded_ind</span> :
  well_founded -&gt;
  <span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>,
    (<span class="kr">forall</span> <span class="nv">x</span>, (<span class="kr">forall</span> <span class="nv">y</span>, R y x -&gt; P y) -&gt; P x) -&gt;
    <span class="kr">forall</span> <span class="nv">a</span>, P a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>A</var><span class="hyp-type"><b>: </b><span><span class="kt">Type</span></span></span></span><br><span><var>R</var><span class="hyp-type"><b>: </b><span>A -&gt; A -&gt; <span class="kt">Prop</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded -&gt;
<span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, (<span class="kr">forall</span> <span class="nv">y</span> : A, R y x -&gt; P y) -&gt; P x) -&gt;
<span class="kr">forall</span> <span class="nv">a</span> : A, P a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>83</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span> Hwf P H a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>86</q><br><q>87</q><br><span><var>Hwf</var><span class="hyp-type"><b>: </b><span>well_founded</span></span></span><br><span><var>P</var><span class="hyp-type"><b>: </b><span>A -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> : A, (<span class="kr">forall</span> <span class="nv">y</span> : A, R y x -&gt; P y) -&gt; P x</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> Acc_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>8d</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : A,
(<span class="kr">forall</span> <span class="nv">y</span> : A, R y x -&gt; Acc y) -&gt;
(<span class="kr">forall</span> <span class="nv">y</span> : A, R y x -&gt; P y) -&gt; P x</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>8d</q><label class="goal-separator"><hr></label><div class="goal-conclusion">Acc a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>95</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>86</q><br><q>87</q><br><q>8e</q><br><q>8f</q><br><q>90</q><br><span><var>a, x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A, R y x -&gt; Acc y</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : A, R y x -&gt; P y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">P x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>9f</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : A, R y x -&gt; P y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>8d</q><span class="goal-separator"><hr></span><q>99</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Hwf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Specifically, the above theorem yields the induction principle if we provide a proof of the well-foundedness of <span class="math">\(R\)</span>.
Instead of requiring that the whole relation is well-founded, we could also restrict our induction to the 'accessible part' of <span class="math">\(R\)</span>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Theorem</span> <span class="nf">well_founded_ind_alt</span> :
  <span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>,
    (<span class="kr">forall</span> <span class="nv">x</span>, (<span class="kr">forall</span> <span class="nv">y</span>, R y x -&gt; P y) -&gt; P x) -&gt;
    <span class="kr">forall</span> <span class="nv">a</span>, Acc a -&gt; P a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>85</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">P</span> : A -&gt; <span class="kt">Prop</span>,
(<span class="kr">forall</span> <span class="nv">x</span> : A, (<span class="kr">forall</span> <span class="nv">y</span> : A, R y x -&gt; P y) -&gt; P x) -&gt;
<span class="kr">forall</span> <span class="nv">a</span> : A, Acc a -&gt; P a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>ac</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span> P H a Ha.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>86</q><br><q>87</q><br><q>8f</q><br><q>90</q><br><q>91</q><br><span><var>Ha</var><span class="hyp-type"><b>: </b><span>Acc a</span></span></span><br></div><span class="goal-separator"><hr></span><q>92</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> Acc_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>b3</q><span class="goal-separator"><hr></span><q>96</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>b3</q><label class="goal-separator"><hr></label><q>99</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>b7</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>86</q><br><q>87</q><br><q>8f</q><br><q>90</q><br><q>91</q><br><q>b4</q><br><span><var>x</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><q>a1</q><br><q>a2</q><br></div><span class="goal-separator"><hr></span><q>a3</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>bf</q><span class="goal-separator"><hr></span><q>a7</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>b3</q><span class="goal-separator"><hr></span><q>99</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">WfInd</span>.</span></span></pre><p>Unfortunately, the above theorem cannot be directly used with the <code class="highlight coq"><span class="nb">induction</span></code> tactic. Therefore, we will always use <code class="highlight coq"><span class="n">well_founded_ind</span></code>, which requires a proof of well-foundedness.
Let's prove the well-foundedness of the most fundamental relation: the standard ordering of natural numbers.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Theorem</span> <span class="nf">lt_wf</span> : well_founded lt.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded lt</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>c8</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">unfold</span> well_founded.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : nat, Acc lt a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">induction</span> a <span class="nb">using</span> strong_ind_nat.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">m</span> : nat, m &lt; a -&gt; Acc lt m</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc lt a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : nat, y &lt; a -&gt; Acc lt y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">lt_wf_ind</span> := well_founded_ind lt_wf.</span></span></pre><p>We now have all the tools we need to apply well-founded induction on our toy problem.
Also note that <code class="highlight coq"><span class="n">lt_wf_ind</span></code>, which is the well-founded induction principle specialized to natural numbers, is precisely equal to the strong induction principle as defined earlier.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Check</span> lt_wf_ind.</label><small class="alectryon-output a:show"><div><div class="alectryon-messages"><blockquote class="alectryon-message">lt_wf_ind
     : <span class="kr">forall</span> <span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>,
       (<span class="kr">forall</span> <span class="nv">x</span> : nat,
        (<span class="kr">forall</span> <span class="nv">y</span> : nat, y &lt; x -&gt; P y) -&gt; P x) -&gt;
       <span class="kr">forall</span> <span class="nv">a</span> : nat, P a</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">k</span>, sum_odd k = k*k.</label><q>1d</q><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><q>5</q><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">induction</span> k <span class="nb">using</span> lt_wf_ind.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>d</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : nat, y &lt; k -&gt; sum_odd y = y * y</span></span></span><br></div><span class="goal-separator"><hr></span><q>70</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">destruct</span> k.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : nat, y &lt; <span class="mi">0</span> -&gt; sum_odd y = y * y</span></span></span><br></div><span class="goal-separator"><hr></span><q>9</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>d</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : nat, y &lt; S k -&gt; sum_odd y = y * y</span></span></span><br></div><label class="goal-separator"><hr></label><q>f</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>e3</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e8</q><span class="goal-separator"><hr></span><q>f</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>e8</q><span class="goal-separator"><hr></span><q>18</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">rewrite</span> H; <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>To conclude this section, we present a generalization of <code class="highlight coq"><span class="n">lt_wf</span></code>:
for any type <code class="highlight coq"><span class="n">A</span></code>, given a function <code class="highlight coq"><span class="n">f</span></code> that maps elements of <code class="highlight coq"><span class="n">A</span></code> to natural numbers, the relation that compares the images under <code class="highlight coq"><span class="n">f</span></code> is well-founded.
As we will see <a class="reference internal" href="#implementation">later</a>, this result is frequently useful in practice.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Section</span> <span class="nf">WfNat</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">A</span> : <span class="kt">Type</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Variable</span> <span class="nv">f</span> : A -&gt; nat.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">ltof</span> (<span class="nv">a</span> <span class="nv">b</span> : A) := f a &lt; f b.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Theorem</span> <span class="nf">well_founded_ltof</span> : well_founded ltof.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>86</q><br><span><var>f</var><span class="hyp-type"><b>: </b><span>A -&gt; nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">well_founded ltof</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>f3</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><q>f3</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">enough</span> (<span class="kr">forall</span> <span class="nv">n</span> <span class="nv">a</span>, f a &lt; n -&gt; Acc ltof a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>86</q><br><q>f6</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A), f a &lt; n -&gt; Acc ltof a</span></span></span><br></div><span class="goal-separator"><hr></span><q>f7</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>f5</q><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n</span> : nat) (<span class="nv">a</span> : A), f a &lt; n -&gt; Acc ltof a</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>fc</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">unfold</span> well_founded.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>fd</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : A, Acc ltof a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>86</q><br><q>f6</q><br><q>fe</q><br><q>91</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc ltof a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> H <span class="kr">with</span> (S (f a)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>10b</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f a &lt; S (f a)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>f5</q><span class="goal-separator"><hr></span><q>101</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">induction</span> n;
    <span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>86</q><br><q>f6</q><br><q>91</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f a &lt; <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><q>10c</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>86</q><br><q>f6</q><br><q>2a</q><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">a</span> : A, f a &lt; n -&gt; Acc ltof a</span></span></span><br><q>91</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span>f a &lt; S n</span></span></span><br></div><label class="goal-separator"><hr></label><q>10c</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>116</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.  <span class="c">(* contradiction *)</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>11b</q><span class="goal-separator"><hr></span><q>10c</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>11b</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">y</span> : A, ltof y a -&gt; Acc ltof y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>86</q><br><q>f6</q><br><q>2a</q><br><q>11c</q><br><q>91</q><br><q>11d</q><br><span><var>y</var><span class="hyp-type"><b>: </b><span>A</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>ltof y a</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Acc ltof y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> IHn.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>12a</q><span class="goal-separator"><hr></span><div class="goal-conclusion">f y &lt; n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">unfold</span> ltof <span class="kr">in</span> H0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>86</q><br><q>f6</q><br><q>2a</q><br><q>11c</q><br><q>91</q><br><q>11d</q><br><q>12b</q><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>f y &lt; f a</span></span></span><br></div><span class="goal-separator"><hr></span><q>131</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">End</span> <span class="nf">WfNat</span>.</span><span class="alectryon-wsp">
</span></span></pre><p>All the above results are available in the standard library (<a class="reference external" href="https://rocq-prover.org/doc/V8.20.1/stdlib/Coq.Init.Wf.html">Init.Wf</a> and <a class="reference external" href="https://rocq-prover.org/doc/V8.20.1/stdlib/Coq.Arith.Wf_nat.html">Arith.Wf_nat</a>).
In the remainder of this tutorial, we will use the declarations from the standard library.</p>
<!-- This means that, in particular, strong induction (as a special case of well-founded induction) is available through the standard library, which is perhaps not widely known. -->
<!-- https://github.com/rocq-prover/rocq/issues/5343 -->
<!-- https://github.com/rocq-community/coq-tricks?tab=readme-ov-file#ltac -->
</section>
</section>
<section id="well-founded-recursion">
<h2>Well-founded recursion</h2>
<p>In Rocq, functions on inductive types are generally defined using <code class="highlight coq"><span class="kn">Fixpoint</span></code>.
Such definitions must terminate.
To guarantee this, the definition must satisfy (syntactical) constraints on one of the arguments, called the <em>decreasing argument</em>.
Namely, recursive calls must operate on structural subterms of this argument.
For example, a function on natural numbers may recur on the predecessor, and a function on lists may recur on the tail.</p>
<p>However, not all functions have this shape.
A simple counterexample is Euclid's algorithm for computing the greatest common divisor.
The following definition is not allowed in Rocq, since it is not structurally recursive. <a class="reference internal" href="#target-6">[‚Ä†]</a></p>
<span class="target" id="naive-gcd"></span><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input alectryon-failed"><span class="kn">Fixpoint</span> <span class="nf">gcd</span> (<span class="nv">a</span> <span class="nv">b</span> : nat) : nat :=
  <span class="kr">match</span> b <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; a
  | _ =&gt; gcd b (a mod b)
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Cannot guess decreasing argument of <span class="kr">fix</span>.</blockquote></div></div></small></span></pre><p>This function does terminate, of course, since the second argument strictly decreases each recursive call.
Formally, <code class="highlight coq"><span class="o">&lt;</span></code> is a well-founded relation on <code class="highlight coq"><span class="n">nat</span></code> (as proven in <a class="reference internal" href="#well-founded-induction">Well-founded induction</a>), so only a finite chain of recursive calls is required.
Because it relies on well-foundedness, we refer to this method of defining recursive functions as <em>well-founded recursion</em>.</p>
<p>Unfortunately, Rocq cannot automatically infer the above reasoning, so we must explicitly specify and prove why the function terminates.
In this section we will compare different methods to perform well-founded recursion, using Euclid's algorithm as a running example.
This is based on a paper by <a class="reference internal" href="#leroy-2024">Leroy (2024)</a>, which uses the same example.
Specifically, we will consider <a class="reference external" href="https://rocq-prover.org/doc/V8.20.1/refman/using/libraries/funind.html">Function</a>, <a class="reference external" href="https://mattam82.github.io/Coq-Equations">Equations</a>, <a class="reference external" href="https://rocq-prover.org/doc/V8.20.1/refman/addendum/program.html#program-fixpoint">Program Fixpoint</a>, and lastly the method proposed by Leroy, which we refer to as <em>Acc-recursion</em>.</p>
<p id="leroy-s-criteria">We will evaluate each method based on a number of criteria, similarly to Leroy:</p>
<ol class="arabic simple">
<li><p>Legibility of definitions.</p></li>
<li><p>Legibility of extracted code.</p></li>
<li><p>Ease of proving properties.</p></li>
<li><p>No axioms used.</p></li>
</ol>
<!-- TODO: shortly clarify each criterion -->
<small><p id="target-6">‚Ä† Actually, if we define the second case as <code class="highlight coq"><span class="n">S</span> <span class="n">b'</span> <span class="o">=&gt;</span> <span class="n">gcd</span> <span class="o">(</span><span class="n">S</span> <span class="n">b'</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="n">mod</span> <span class="o">(</span><span class="n">S</span> <span class="n">b'</span><span class="o">))</span></code>, the definition is accepted as structurally recursive!
This is because <code class="highlight coq"><span class="n">a</span> <span class="n">mod</span> <span class="o">(</span><span class="n">S</span> <span class="n">b'</span><span class="o">)</span></code> simplifies to a subtraction, which 'preserves being a subterm' according to the <a class="reference external" href="https://rocq-prover.org/doc/V8.20.1/stdlib/Coq.Init.Nat.html#gcd">standard library</a>.
Hence, it is not necessary to use well-founded recursion to implement Euclid's algorithm, but it functions as an uncomplicated example for our purposes.</p>
</small><section id="preparation">
<h3>Preparation</h3>
<p>Before implementing and verifying Euclid's algorithm, we need a formal definition of the greatest common divisor.
We will also prove some properties. It is best to derive them from the definition, rather than the various implementations. This enables reuse and avoids dependence on specialized concepts like <code class="highlight coq"><span class="n">Acc</span></code>.</p>
<p>The <em>greatest common divisor</em> (GCD) of two integers <code class="highlight coq"><span class="n">a</span></code>, <code class="highlight coq"><span class="n">b</span></code> is the largest integer <code class="highlight coq"><span class="n">x</span></code> that divides both <code class="highlight coq"><span class="n">a</span></code> and <code class="highlight coq"><span class="n">b</span></code>.
Equivalently, <code class="highlight coq"><span class="n">x</span></code> is a common divisor (CD) of <code class="highlight coq"><span class="n">a</span></code> and <code class="highlight coq"><span class="n">b</span></code>, and every common divisor of <code class="highlight coq"><span class="n">a</span></code> and <code class="highlight coq"><span class="n">b</span></code> also divides <code class="highlight coq"><span class="n">x</span></code>.
We use <code class="highlight coq"><span class="n">Nat</span><span class="o">.</span><span class="n">divide</span></code> from the standard library, which already provides a range of helpful lemmas.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">is_cd</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">x</span> : nat) : <span class="kt">Prop</span> :=
  Nat.divide x a /\ Nat.divide x b.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">is_gcd</span> (<span class="nv">a</span> <span class="nv">b</span> <span class="nv">x</span> : nat) : <span class="kt">Prop</span> :=
  is_cd a b x /\ <span class="kr">forall</span> <span class="nv">y</span>, is_cd a b y -&gt; Nat.divide y x.</span></span></pre><!-- We write `Nat.divide y x` instead of the more intuitive `y <= x`, since it handles zeros more neatly. -->
<p>First, let's prove some corner cases. These correspond to the base case of the algorithm.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">is_cd_0</span> : <span class="kr">forall</span> <span class="nv">x</span>, is_cd x <span class="mi">0</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : nat, is_cd x <span class="mi">0</span> x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>139</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Nat.divide x x</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>140</q><label class="goal-separator"><hr></label><div class="goal-conclusion">Nat.divide x <span class="mi">0</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>13f</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>140</q><span class="goal-separator"><hr></span><q>145</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> Nat.divide_0_r.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">is_gcd_0</span> : <span class="kr">forall</span> <span class="nv">x</span>, is_gcd x <span class="mi">0</span> x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : nat, is_gcd x <span class="mi">0</span> x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>14c</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">firstorder using</span> is_cd_0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Next, we essentially prove the step case of Euclid's algorithm: <code class="highlight coq"><span class="n">gcd</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span></code> is equal to <code class="highlight coq"><span class="n">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="n">mod</span> <span class="n">b</span><span class="o">)</span></code>.
To do this, it is useful to prove some identities involving division and modulo.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">divide_mod_1</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">x</span>,
  Nat.divide x a -&gt; Nat.divide x b -&gt; Nat.divide x (a mod b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">x</span> : nat,
Nat.divide x a -&gt;
Nat.divide x b -&gt; Nat.divide x (a mod b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>151</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span> a b x H1 H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Nat.divide x a</span></span></span><br><span><var>H2</var><span class="hyp-type"><b>: </b><span>Nat.divide x b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Nat.divide x (a mod b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">destruct</span> H1 <span class="kr">as</span> [A HA].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b, x, A</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>HA</var><span class="hyp-type"><b>: </b><span>a = A * x</span></span></span><br><q>15b</q><br></div><span class="goal-separator"><hr></span><q>15c</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">destruct</span> H2 <span class="kr">as</span> [B HB].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>161</q><br><q>162</q><br><span><var>B</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>HB</var><span class="hyp-type"><b>: </b><span>b = B * x</span></span></span><br></div><span class="goal-separator"><hr></span><q>15c</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kr">exists</span> (<span class="nv">A</span> - B * (a/b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>166</q><span class="goal-separator"><hr></span><div class="goal-conclusion">a mod b = (A - B * (a / b)) * x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">pose proof</span> (Nat.div_mod_eq a b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>161</q><br><q>162</q><br><q>167</q><br><q>168</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span>a = b * (a / b) + a mod b</span></span></span><br></div><span class="goal-separator"><hr></span><q>16c</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> Nat.mul_sub_distr_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>170</q><span class="goal-separator"><hr></span><div class="goal-conclusion">a mod b = A * x - B * (a / b) * x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">divide_mod_2</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">x</span>,
  Nat.divide x (a mod b) -&gt; Nat.divide x b -&gt; Nat.divide x a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">x</span> : nat,
Nat.divide x (a mod b) -&gt;
Nat.divide x b -&gt; Nat.divide x a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>177</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span> a b x H1 H2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>159</q><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>Nat.divide x (a mod b)</span></span></span><br><q>15b</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Nat.divide x a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">destruct</span> H1 <span class="kr">as</span> [A HA].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>161</q><br><span><var>HA</var><span class="hyp-type"><b>: </b><span>a mod b = A * x</span></span></span><br><q>15b</q><br></div><span class="goal-separator"><hr></span><q>180</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">destruct</span> H2 <span class="kr">as</span> [B HB].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>161</q><br><q>185</q><br><q>167</q><br><q>168</q><br></div><span class="goal-separator"><hr></span><q>180</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kr">exists</span> (<span class="nv">A</span> + B * (a/b)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>189</q><span class="goal-separator"><hr></span><div class="goal-conclusion">a = (A + B * (a / b)) * x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">pose proof</span> (Nat.div_mod_eq a b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>161</q><br><q>185</q><br><q>167</q><br><q>168</q><br><q>171</q><br></div><span class="goal-separator"><hr></span><q>18d</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">is_cd_step</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">x</span>,
  is_cd a b x -&gt; is_cd b (a mod b) x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">x</span> : nat, is_cd a b x -&gt; is_cd b (a mod b) x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>193</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>159</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_cd a b x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Nat.divide x b</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>19a</q><label class="goal-separator"><hr></label><q>15c</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="mi">2</span>: <span class="nb">apply</span> divide_mod_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>199</q><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>19a</q><label class="goal-separator"><hr></label><q>180</q></blockquote><blockquote class="alectryon-goal"><q>19a</q><label class="goal-separator"><hr></label><q>19c</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">firstorder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">is_cd_step_rev</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">x</span>,
  is_cd b (a mod b) x -&gt; is_cd a b x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">x</span> : nat, is_cd b (a mod b) x -&gt; is_cd a b x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1a5</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>159</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_cd b (a mod b) x</span></span></span><br></div><span class="goal-separator"><hr></span><q>180</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>1ac</q><label class="goal-separator"><hr></label><q>19c</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="mi">1</span>: <span class="nb">apply</span> divide_mod_2 <span class="kr">with</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1ac</q><span class="goal-separator"><hr></span><q>15c</q></blockquote><div class="alectryon-extra-goals"><q>1af</q><q>1af</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">firstorder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">is_gcd_step_rev</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">x</span>,
  is_gcd b (a mod b) x -&gt; is_gcd a b x.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">x</span> : nat,
is_gcd b (a mod b) x -&gt; is_gcd a b x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1b5</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* exercise *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span></span></pre></section>
<section id="function">
<h3>Function</h3>
<p>Now, we are ready to implement <code class="highlight coq"><span class="n">gcd</span></code>.
Our first method of choice is the functional induction plugin.
Its main command, <code class="highlight coq"><span class="kn">Function</span></code>, which behaves like <code class="highlight coq"><span class="kn">Fixpoint</span></code>, allows us to perform well-founded recursion using the <code class="highlight coq"><span class="o">{</span><span class="kn">wf</span> <span class="n">R</span> <span class="n">x</span><span class="o">}</span></code> annotation.
Here, <code class="highlight coq"><span class="n">x</span></code> should be the decreasing argument, and <code class="highlight coq"><span class="n">R</span></code> a well-founded ordering relation on the type of <code class="highlight coq"><span class="n">x</span></code>, such that <code class="highlight coq"><span class="n">x</span></code> decreases every recursive call.
In the case of <code class="highlight coq"><span class="n">gcd</span></code>, the decreasing argument is <code class="highlight coq"><span class="n">b</span></code>, and the relation is simply <code class="highlight coq"><span class="n">lt</span></code>.</p>
<!-- TODO: explain (somewhere) why `a` cannot be the decreasing argument -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> FunInd.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Recdef.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Function</span> <span class="nf">gcd_1</span> (a b : nat) {<span class="kn">wf</span> lt b} : nat :=
  <span class="kr">match</span> b <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; a
  | _ =&gt; gcd_1 b (a mod b)
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">n</span> : nat, b = S n -&gt; a mod S n &lt; S n</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><q>ca</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="c">(* It remains to prove some obligations... *)</span>
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1ba</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>1bb</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto using</span> Nat.mod_upper_bound.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><q>c8</q></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> lt_wf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span></span></pre><!-- TODO: we could examine `gcd_1_ind` -->
<p>Unlike <code class="highlight coq"><span class="kn">Fixpoint</span></code>, after the definition, we are left with some proof obligations. We need to prove that:</p>
<ul class="simple">
<li><p><code class="highlight coq"><span class="n">b</span></code> is decreasing in each recursive call;</p></li>
<li><p>the relation <code class="highlight coq"><span class="n">lt</span></code> is well-founded.</p></li>
</ul>
<p>In this case, instead of <code class="highlight coq"><span class="o">{</span><span class="kn">wf</span> <span class="n">lt</span> <span class="n">b</span><span class="o">}</span></code>, we could have used the annotation <code class="highlight coq"><span class="o">{</span><span class="kn">measure</span> <span class="n">id</span> <span class="n">b</span><span class="o">}</span></code>.
This uses the idea of <code class="highlight coq"><span class="n">well_founded_ltof</span></code> as discussed earlier: it asserts that <code class="highlight coq"><span class="n">id</span> <span class="n">b</span></code> decreases with each recursive call. For our purposes, <code class="highlight coq"><span class="n">id</span></code> suffices, though any mapping from the type of <code class="highlight coq"><span class="n">b</span></code> to <code class="highlight coq"><span class="n">nat</span></code> is allowed.
With <code class="highlight coq"><span class="kn">measure</span></code>, only the first obligation remains, since it is already known that <code class="highlight coq"><span class="n">lt</span></code> is well-founded.</p>
<p>Note that we finish the obligations with <code class="highlight coq"><span class="kn">Defined</span></code> instead of <code class="highlight coq"><span class="kn">Qed</span></code>.
This makes the proof term transparent, enabling computation.
Try it yourself: with <code class="highlight coq"><span class="kn">Qed</span></code> instead of <code class="highlight coq"><span class="kn">Defined</span></code>, the following would not output 6.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Compute</span> gcd_1 <span class="mi">12</span> <span class="mi">18</span>.</label><small class="alectryon-output a:show"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="mi">6</span>
: nat</blockquote></div></div></small></span></pre><p>Next, we check the extracted code (OCaml), which looks clean.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Extraction</span> gcd_1.</label><small class="alectryon-output a:show"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="sd">(** val gcd_1 : nat -&gt; nat -&gt; nat **)</span>

<span class="kr">let rec</span> <span class="nv">gcd_1</span> <span class="nv">a</span> = function
| O -&gt; a
| S n -&gt; gcd_1 (S n) (Nat.modulo a (S n))</blockquote></div></div></small></span></pre><p>Lastly, we will prove the correctness of <code class="highlight coq"><span class="n">gcd_1</span></code>.
Importantly, if we would use <code class="highlight coq"><span class="nb">induction</span> <span class="n">b</span></code>, we would get stuck.
Instead, we should use the custom tactic <code class="highlight coq"><span class="nb">functional induction</span></code>, which introduces a more relevant induction hypothesis.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">gcd_1_ok</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, is_gcd a b (gcd_1 a b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : nat, is_gcd a b (gcd_1 a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1c6</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, b</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_gcd a b (gcd_1 a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">functional induction</span> (gcd_1 a b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>d4</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_gcd a <span class="mi">0</span> a</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1ce</q><br><span><var>y</var><span class="hyp-type"><b>: </b><span><span class="kr">match</span> b <span class="kr">with</span>
| <span class="mi">0</span> =&gt; <span class="kt">False</span>
| S _ =&gt; <span class="kt">True</span>
<span class="kr">end</span></span></span></span><br><span><var>IHn</var><span class="hyp-type"><b>: </b><span>is_gcd b (a mod b) (gcd_1 b (a mod b))</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">is_gcd a b (gcd_1 b (a mod b))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>1d2</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> is_gcd_0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1d7</q><span class="goal-separator"><hr></span><q>1da</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> is_gcd_step_rev.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1d7</q><span class="goal-separator"><hr></span><div class="goal-conclusion">is_gcd b (a mod b) (gcd_1 b (a mod b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>After our preparation in the previous section, the proof is simple.
Since <code class="highlight coq"><span class="n">is_gcd</span></code> characterizes the GCD, any further properties we want to prove can start from <code class="highlight coq"><span class="n">is_gcd</span></code> instead of the implementation. (For example, as an exercise, try to prove that <code class="highlight coq"><span class="n">gcd_1</span></code> is associative without <code class="highlight coq"><span class="nb">functional induction</span></code>.) This means that criterion 3 is satisfied.
Looking at the definition and extracted code, criteria 1 and 2 are also met.
Lastly, since we used no axioms, criterion 4 is also fulfilled.</p>
<p>There is one problem with <code class="highlight coq"><span class="kn">Function</span></code>: it is considered 'legacy functionality'.
Users are recommended to use the Equations plugin instead. That is the method we will look at next.</p>
</section>
<section id="equations">
<h3>Equations</h3>
<p>The Equations plugin by <a class="reference internal" href="#sozeau-and-mangin-2019">Sozeau and Mangin (2019)</a> boasts many features, including a different syntax for function definitions, but we will focus on well-founded recursion.
As with <code class="highlight coq"><span class="kn">Function</span></code>, an <code class="highlight coq"><span class="kn">Equations</span></code> definition supports a <code class="highlight coq"><span class="kn">wf</span> <span class="n">x</span> <span class="n">R</span></code> annotation to enable well-founded recursion. (Note that the arguments are swapped!)</p>
<!-- Actually, in this case, we can even omit `lt`. -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">From</span> <span class="kn">Equations</span> <span class="nf">Require</span> <span class="nv">Import</span> <span class="nv">Equations</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Equations</span> <span class="nf">gcd_2</span> (<span class="nv">a</span> <span class="nv">b</span> : nat) : nat <span class="bp">by</span> <span class="kn">wf</span> b lt :=
  gcd_2 x <span class="mi">0</span> := x;
  gcd_2 x y := gcd_2 y (x mod y).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>x, n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>gcd_2</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kr">forall</span> <span class="nv">x</span> : nat, x &lt; S n -&gt; nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n - snd (Nat.divmod x n <span class="mi">0</span> n) &lt; S n</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Again, a proof obligation was generated (corresponding to the first obligation of <code class="highlight coq"><span class="n">gcd_1</span></code>).
The goal may look strange at first, but it is merely the (simplified) definition of <code class="highlight coq"><span class="n">Nat</span><span class="o">.</span><span class="n">modulo</span></code>.
In contrast to <code class="highlight coq"><span class="n">gcd_1</span></code>, even if the obligation is opaque, computation is possible:</p>
<!-- However, if we were to use `Eval compute in`, we would need `Set Equations Transparent.`! -->
<!-- TODO: why can the obligation be opaque? -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Compute</span> gcd_2 <span class="mi">12</span> <span class="mi">18</span>.</label><small class="alectryon-output a:show"><div><div class="alectryon-messages"><blockquote class="alectryon-message">= <span class="mi">6</span>
: nat</blockquote></div></div></small></span></pre><p>It has been smooth sailing so far, but the extracted code is unfortunately not very readable.
The issue seems to be that the function is internally uncurried, and the destructuring carries over into the extracted code.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Extraction</span> gcd_2.</label><small class="alectryon-output a:show"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="sd">(** val gcd_2 : nat -&gt; nat -&gt; nat **)</span>

<span class="kr">let</span> <span class="nv">gcd_2</span> <span class="nv">a</span> <span class="nv">b</span> =
  <span class="kr">let rec</span> <span class="nv">fix_F</span> <span class="nv">x</span> =
    <span class="kr">match</span> <span class="kr">let</span> <span class="nv">_</span>,pr2 = x <span class="kr">in</span> pr2 <span class="kr">with</span>
    | O -&gt; <span class="kr">let</span> <span class="nv">pr1</span>,_ = x <span class="kr">in</span> pr1
    | S n -&gt;
      <span class="kr">let</span> <span class="nv">y</span> = (S
        n),(Nat.modulo (<span class="kr">let</span> <span class="nv">pr1</span>,_ = x <span class="kr">in</span> pr1) (S n))
      <span class="kr">in</span>
      fix_F y
  <span class="kr">in</span> fix_F (a,b)</blockquote></div></div></small></span></pre><p>It remains to prove the correctness.
Similarly to the functional induction plugin, Equations offers a custom <code class="highlight coq"><span class="n">funelim</span></code> tactic.
It performs a case analysis according to the function's definition, abstracting away the underlying well-founded induction. This allows for succinct proofs.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">gcd_2_ok</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, is_gcd a b (gcd_2 a b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : nat, is_gcd a b (gcd_2 a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>1ee</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1cd</q><span class="goal-separator"><hr></span><div class="goal-conclusion">is_gcd a b (gcd_2 a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">funelim (gcd_2 a b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>141</q><br><span><var>Heqcall</var><span class="hyp-type"><b>: </b><span>x = gcd_2 x <span class="mi">0</span></span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_gcd x <span class="mi">0</span> x</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1e8</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span>is_gcd (S n) (x mod S n) (gcd_2 (S n) (x mod S n))</span></span></span><br><span><var>Heqcall</var><span class="hyp-type"><b>: </b><span>gcd_2 (S n) (x mod S n) = gcd_2 x (S n)</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">is_gcd x (S n) (gcd_2 (S n) (x mod S n))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>1f8</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> is_gcd_0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1fe</q><span class="goal-separator"><hr></span><q>201</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> is_gcd_step_rev.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1fe</q><span class="goal-separator"><hr></span><div class="goal-conclusion">is_gcd (S n) (x mod S n) (gcd_2 (S n) (x mod S n))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>In summary, apart from the legibility of the extracted code (#2), the Equations plugin fulfills all criteria.</p>
</section>
<section id="program-fixpoint">
<h3>Program Fixpoint</h3>
<p><code class="highlight coq"><span class="kn">Fixpoint</span></code> can be prefixed with <code class="highlight coq"><span class="n">Program</span></code>, enabling 'program mode'.
Then, as with <code class="highlight coq"><span class="kn">Function</span></code>, it supports well-founded recursion through <code class="highlight coq"><span class="o">{</span><span class="kn">wf</span> <span class="n">R</span> <span class="n">x</span><span class="o">}</span></code> annotations.</p>
<!-- or `measure` -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Program.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Fixpoint</span> <span class="nf">gcd_3</span> (<span class="nv">a</span> <span class="nv">b</span> : nat) {<span class="nv">wf</span> <span class="nv">lt</span> <span class="nv">b</span>} : nat :=
  <span class="kr">match</span> b <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; a
  | _ =&gt; gcd_3 b (a mod b)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1ce</q><br><span><var>gcd_3</var><span class="hyp-type"><b>: </b><span>nat -&gt; <span class="kr">forall</span> <span class="nv">b0</span> : nat, b0 &lt; b -&gt; nat</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span><span class="mi">0</span> &lt;&gt; b</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">a mod b &lt; b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto using</span> Nat.mod_upper_bound.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>The extracted code (omitted) is cluttered, since proof obligations and dependent wrappers bleed into it, but there is a more pressing issue.
Whereas <code class="highlight coq"><span class="kn">Equations</span></code> automatically provides <em>reduction lemmas</em> (such as <code class="highlight coq"><span class="n">gcd_2_equation_1</span></code>) and an elimination principle (<code class="highlight coq"><span class="n">gcd_2_elim</span></code>), <code class="highlight coq"><span class="kn">Program Fixpoint</span></code> is much more bare-bones.</p>
<!-- boilerplate-heavy, artificially verbose, non-idiomatic -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Check</span> gcd_2_equation_1.  <span class="c">(* generated by Equations *)</span></label><small class="alectryon-output a:show"><div><div class="alectryon-messages"><blockquote class="alectryon-message">gcd_2_equation_1
     : <span class="kr">forall</span> <span class="nv">x</span> : nat, gcd_2 x <span class="mi">0</span> = x</blockquote></div></div></small></span></pre><p>To verify <code class="highlight coq"><span class="n">gcd_3</span></code>, we need an analogous lemma, but proving it is not easy.
Since <code class="highlight coq"><span class="n">gcd_3</span></code> is defined using the <code class="highlight coq"><span class="n">Fix</span></code> combinator, <code class="highlight coq"><span class="nb">simpl</span></code> is unable to unfold <code class="highlight coq"><span class="n">gcd_3</span> <span class="n">a</span> <span class="mi">0</span></code>.
Apart from a <a class="reference external" href="https://stackoverflow.com/q/36329256">Stack Overflow post</a>, little documentation is available.
The key is the <code class="highlight coq"><span class="n">fix_sub_eq</span></code> lemma. It is important to note that it carries a (hidden) functional extensionality hypothesis, i.e., it is axiomatic!</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Fact</span> <span class="nf">gcd_3_equation_1</span> : <span class="kr">forall</span> <span class="nv">a</span>, gcd_3 a <span class="mi">0</span> = a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : nat, gcd_3 a <span class="mi">0</span> = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>214</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">gcd_3 a <span class="mi">0</span> = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">unfold</span> gcd_3.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">gcd_3_func (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) a <span class="mi">0</span>) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">unfold</span> gcd_3_func.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">Fix_sub {_ : nat &amp; nat}
  (MR lt
     (<span class="kr">fun</span> <span class="nv">recarg</span> : {_ : nat &amp; nat} =&gt; projT2 recarg))
  gcd_3_func_obligation_3
  (<span class="kr">fun</span> <span class="nv">_</span> : {_ : nat &amp; nat} =&gt; nat)
  (<span class="kr">fun</span> (<span class="nv">recarg</span> : {_ : nat &amp; nat})
     (<span class="nv">gcd_3&#39;</span> : {recarg&#39; : {_ : nat &amp; nat}
               | projT2 recarg&#39; &lt; projT2 recarg} -&gt;
               nat) =&gt;
   <span class="kr">match</span>
     projT2 recarg <span class="kr">as</span> b&#39;
     <span class="kr">return</span> (b&#39; = projT2 recarg -&gt; nat)
   <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; <span class="kr">fun</span> <span class="nv">_</span> : <span class="mi">0</span> = projT2 recarg =&gt; projT1 recarg
   | S n =&gt;
       <span class="kr">fun</span> <span class="nv">Heq_b</span> : S n = projT2 recarg =&gt;
       gcd_3&#39;
         (exist
            (<span class="kr">fun</span> <span class="nv">recarg&#39;</span> : {_ : nat &amp; nat} =&gt;
             projT2 recarg&#39; &lt; projT2 recarg)
            (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat)
               (projT2 recarg)
               (projT1 recarg mod projT2 recarg))
            (gcd_3_func_obligation_1 (projT1 recarg)
               (projT2 recarg) (S n)
               (gcd_3_func_obligation_2 n) Heq_b))
   <span class="kr">end</span> eq_refl) (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) a <span class="mi">0</span>) = a</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> fix_sub_eq.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">(<span class="kr">let</span> <span class="nv">f_sub</span> :=
   <span class="kr">fun</span> (<span class="nv">recarg</span> : {_ : nat &amp; nat})
     (<span class="nv">gcd_3&#39;</span> : {recarg&#39; : {_ : nat &amp; nat}
               | projT2 recarg&#39; &lt; projT2 recarg} -&gt;
               nat) =&gt;
   <span class="kr">match</span>
     projT2 recarg <span class="kr">as</span> b&#39;
     <span class="kr">return</span> (b&#39; = projT2 recarg -&gt; nat)
   <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; <span class="kr">fun</span> <span class="nv">_</span> : <span class="mi">0</span> = projT2 recarg =&gt; projT1 recarg
   | S n =&gt;
       <span class="kr">fun</span> <span class="nv">Heq_b</span> : S n = projT2 recarg =&gt;
       gcd_3&#39;
         (exist
            (<span class="kr">fun</span> <span class="nv">recarg&#39;</span> : {_ : nat &amp; nat} =&gt;
             projT2 recarg&#39; &lt; projT2 recarg)
            (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat)
               (projT2 recarg)
               (projT1 recarg mod projT2 recarg))
            (gcd_3_func_obligation_1 (projT1 recarg)
               (projT2 recarg) (S n)
               (gcd_3_func_obligation_2 n) Heq_b))
   <span class="kr">end</span> eq_refl <span class="kr">in</span>
 f_sub (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) a <span class="mi">0</span>)
   (<span class="kr">fun</span>
      <span class="nv">y</span> : {y : {_ : nat &amp; nat}
          | MR lt
              (<span class="kr">fun</span> <span class="nv">recarg</span> : {_ : nat &amp; nat} =&gt;
               projT2 recarg) y
              (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) a <span class="mi">0</span>)} =&gt;
    Fix_sub {_ : nat &amp; nat}
      (MR lt
         (<span class="kr">fun</span> <span class="nv">recarg</span> : {_ : nat &amp; nat} =&gt;
          projT2 recarg)) gcd_3_func_obligation_3
      (<span class="kr">fun</span> <span class="nv">_</span> : {_ : nat &amp; nat} =&gt; nat)
      (<span class="kr">fun</span> (<span class="nv">recarg</span> : {_ : nat &amp; nat})
         (<span class="nv">gcd_3&#39;</span> : {recarg&#39; : {_ : nat &amp; nat}
                   | projT2 recarg&#39; &lt; projT2 recarg} -&gt;
                   nat) =&gt;
       <span class="kr">match</span>
         projT2 recarg <span class="kr">as</span> b&#39;
         <span class="kr">return</span> (b&#39; = projT2 recarg -&gt; nat)
       <span class="kr">with</span>
       | <span class="mi">0</span> =&gt;
           <span class="kr">fun</span> <span class="nv">_</span> : <span class="mi">0</span> = projT2 recarg =&gt; projT1 recarg
       | S n =&gt;
           <span class="kr">fun</span> <span class="nv">Heq_b</span> : S n = projT2 recarg =&gt;
           gcd_3&#39;
             (exist
                (<span class="kr">fun</span> <span class="nv">recarg&#39;</span> : {_ : nat &amp; nat} =&gt;
                 projT2 recarg&#39; &lt; projT2 recarg)
                (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat)
                   (projT2 recarg)
                   (projT1 recarg mod projT2 recarg))
                (gcd_3_func_obligation_1
                   (projT1 recarg) (projT2 recarg)
                   (S n) (gcd_3_func_obligation_2 n)
                   Heq_b))
       <span class="kr">end</span> eq_refl) (` y))) = a</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>1d3</q><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : {_ : nat &amp; nat})
  (<span class="nv">f</span>
   <span class="nv">g</span> : {y : {_ : nat &amp; nat}
       | MR lt
           (<span class="kr">fun</span> <span class="nv">recarg</span> : {_ : nat &amp; nat} =&gt;
            projT2 recarg) y x} -&gt; nat),
(<span class="kr">forall</span>
   <span class="nv">y</span> : {y : {_ : nat &amp; nat}
       | MR lt
           (<span class="kr">fun</span> <span class="nv">recarg</span> : {_ : nat &amp; nat} =&gt;
            projT2 recarg) y x}, f y = g y) -&gt;
<span class="kr">match</span>
  projT2 x <span class="kr">as</span> b&#39; <span class="kr">return</span> (b&#39; = projT2 x -&gt; nat)
<span class="kr">with</span>
| <span class="mi">0</span> =&gt; <span class="kr">fun</span> <span class="nv">_</span> : <span class="mi">0</span> = projT2 x =&gt; projT1 x
| S n =&gt;
    <span class="kr">fun</span> <span class="nv">Heq_b</span> : S n = projT2 x =&gt;
    f
      (exist
         (<span class="kr">fun</span> <span class="nv">recarg&#39;</span> : {_ : nat &amp; nat} =&gt;
          projT2 recarg&#39; &lt; projT2 x)
         (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) (projT2 x)
            (projT1 x mod projT2 x))
         (gcd_3_func_obligation_1 (projT1 x)
            (projT2 x) (S n)
            (gcd_3_func_obligation_2 n) Heq_b))
<span class="kr">end</span> eq_refl =
<span class="kr">match</span>
  projT2 x <span class="kr">as</span> b&#39; <span class="kr">return</span> (b&#39; = projT2 x -&gt; nat)
<span class="kr">with</span>
| <span class="mi">0</span> =&gt; <span class="kr">fun</span> <span class="nv">_</span> : <span class="mi">0</span> = projT2 x =&gt; projT1 x
| S n =&gt;
    <span class="kr">fun</span> <span class="nv">Heq_b</span> : S n = projT2 x =&gt;
    g
      (exist
         (<span class="kr">fun</span> <span class="nv">recarg&#39;</span> : {_ : nat &amp; nat} =&gt;
          projT2 recarg&#39; &lt; projT2 x)
         (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) (projT2 x)
            (projT1 x mod projT2 x))
         (gcd_3_func_obligation_1 (projT1 x)
            (projT2 x) (S n)
            (gcd_3_func_obligation_2 n) Heq_b))
<span class="kr">end</span> eq_refl</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>226</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1d3</q><span class="goal-separator"><hr></span><q>22a</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>d4</q><br><span><var>x</var><span class="hyp-type"><b>: </b><span>{_ : nat &amp; nat}</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>{y : {_ : nat &amp; nat}
| MR lt
    (<span class="kr">fun</span> <span class="nv">recarg</span> : {_ : nat &amp; nat} =&gt; projT2 recarg)
    y x} -&gt; nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">y</span> : {y : {_ : nat &amp; nat}
      | MR lt
          (<span class="kr">fun</span> <span class="nv">recarg</span> : {_ : nat &amp; nat} =&gt;
           projT2 recarg) y x}, f y = g y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  projT2 x <span class="kr">as</span> b&#39; <span class="kr">return</span> (b&#39; = projT2 x -&gt; nat)
<span class="kr">with</span>
| <span class="mi">0</span> =&gt; <span class="kr">fun</span> <span class="nv">_</span> : <span class="mi">0</span> = projT2 x =&gt; projT1 x
| S n =&gt;
    <span class="kr">fun</span> <span class="nv">Heq_b</span> : S n = projT2 x =&gt;
    f
      (exist
         (<span class="kr">fun</span> <span class="nv">recarg&#39;</span> : {_ : nat &amp; nat} =&gt;
          projT2 recarg&#39; &lt; projT2 x)
         (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) (projT2 x)
            (projT1 x mod projT2 x))
         (gcd_3_func_obligation_1 (projT1 x)
            (projT2 x) (S n)
            (gcd_3_func_obligation_2 n) Heq_b))
<span class="kr">end</span> eq_refl =
<span class="kr">match</span>
  projT2 x <span class="kr">as</span> b&#39; <span class="kr">return</span> (b&#39; = projT2 x -&gt; nat)
<span class="kr">with</span>
| <span class="mi">0</span> =&gt; <span class="kr">fun</span> <span class="nv">_</span> : <span class="mi">0</span> = projT2 x =&gt; projT1 x
| S n =&gt;
    <span class="kr">fun</span> <span class="nv">Heq_b</span> : S n = projT2 x =&gt;
    g
      (exist
         (<span class="kr">fun</span> <span class="nv">recarg&#39;</span> : {_ : nat &amp; nat} =&gt;
          projT2 recarg&#39; &lt; projT2 x)
         (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) (projT2 x)
            (projT1 x mod projT2 x))
         (gcd_3_func_obligation_1 (projT1 x)
            (projT2 x) (S n)
            (gcd_3_func_obligation_2 n) Heq_b))
<span class="kr">end</span> eq_refl</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">destruct</span> x <span class="kr">as</span> [x y].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>{y0 : {_ : nat &amp; nat}
| MR lt
    (<span class="kr">fun</span> <span class="nv">recarg</span> : {_ : nat &amp; nat} =&gt; projT2 recarg)
    y0 (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y)} -&gt; nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">y</span> : {y0 : {_ : nat &amp; nat}
      | MR lt
          (<span class="kr">fun</span> <span class="nv">recarg</span> : {_ : nat &amp; nat} =&gt;
           projT2 recarg) y0
          (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y)},
f y = g y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span>
  projT2 (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y) <span class="kr">as</span> b&#39;
  <span class="kr">return</span>
    (b&#39; = projT2 (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y) -&gt;
     nat)
<span class="kr">with</span>
| <span class="mi">0</span> =&gt;
    <span class="kr">fun</span>
      <span class="nv">_</span> : <span class="mi">0</span> = projT2 (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y)
    =&gt; projT1 (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y)
| S n =&gt;
    <span class="kr">fun</span>
      <span class="nv">Heq_b</span> : S n =
              projT2 (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y)
    =&gt;
    f
      (exist
         (<span class="kr">fun</span> <span class="nv">recarg&#39;</span> : {_ : nat &amp; nat} =&gt;
          projT2 recarg&#39; &lt;
          projT2 (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y))
         (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat)
            (projT2 (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y))
            (projT1 (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y)
             mod projT2
                   (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y)))
         (gcd_3_func_obligation_1
            (projT1 (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y))
            (projT2 (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y))
            (S n) (gcd_3_func_obligation_2 n) Heq_b))
<span class="kr">end</span> eq_refl =
<span class="kr">match</span>
  projT2 (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y) <span class="kr">as</span> b&#39;
  <span class="kr">return</span>
    (b&#39; = projT2 (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y) -&gt;
     nat)
<span class="kr">with</span>
| <span class="mi">0</span> =&gt;
    <span class="kr">fun</span>
      <span class="nv">_</span> : <span class="mi">0</span> = projT2 (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y)
    =&gt; projT1 (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y)
| S n =&gt;
    <span class="kr">fun</span>
      <span class="nv">Heq_b</span> : S n =
              projT2 (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y)
    =&gt;
    g
      (exist
         (<span class="kr">fun</span> <span class="nv">recarg&#39;</span> : {_ : nat &amp; nat} =&gt;
          projT2 recarg&#39; &lt;
          projT2 (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y))
         (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat)
            (projT2 (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y))
            (projT1 (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y)
             mod projT2
                   (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y)))
         (gcd_3_func_obligation_1
            (projT1 (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y))
            (projT2 (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x y))
            (S n) (gcd_3_func_obligation_2 n) Heq_b))
<span class="kr">end</span> eq_refl</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>23b</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">match</span> y <span class="kr">as</span> b&#39; <span class="kr">return</span> (b&#39; = y -&gt; nat) <span class="kr">with</span>
| <span class="mi">0</span> =&gt; <span class="kr">fun</span> <span class="nv">_</span> : <span class="mi">0</span> = y =&gt; x
| S n =&gt;
    <span class="kr">fun</span> <span class="nv">Heq_b</span> : S n = y =&gt;
    f
      (exist
         (<span class="kr">fun</span> <span class="nv">recarg&#39;</span> : {_ : nat &amp; nat} =&gt;
          projT2 recarg&#39; &lt; y)
         (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) y (x mod y))
         (gcd_3_func_obligation_1 x y (S n)
            (gcd_3_func_obligation_2 n) Heq_b))
<span class="kr">end</span> eq_refl =
<span class="kr">match</span> y <span class="kr">as</span> b&#39; <span class="kr">return</span> (b&#39; = y -&gt; nat) <span class="kr">with</span>
| <span class="mi">0</span> =&gt; <span class="kr">fun</span> <span class="nv">_</span> : <span class="mi">0</span> = y =&gt; x
| S n =&gt;
    <span class="kr">fun</span> <span class="nv">Heq_b</span> : S n = y =&gt;
    g
      (exist
         (<span class="kr">fun</span> <span class="nv">recarg&#39;</span> : {_ : nat &amp; nat} =&gt;
          projT2 recarg&#39; &lt; y)
         (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) y (x mod y))
         (gcd_3_func_obligation_1 x y (S n)
            (gcd_3_func_obligation_2 n) Heq_b))
<span class="kr">end</span> eq_refl</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">destruct</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>a, x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>{y : {_ : nat &amp; nat}
| MR lt
    (<span class="kr">fun</span> <span class="nv">recarg</span> : {_ : nat &amp; nat} =&gt; projT2 recarg)
    y (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x <span class="mi">0</span>)} -&gt; nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">y</span> : {y : {_ : nat &amp; nat}
      | MR lt
          (<span class="kr">fun</span> <span class="nv">recarg</span> : {_ : nat &amp; nat} =&gt;
           projT2 recarg) y
          (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x <span class="mi">0</span>)},
f y = g y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x = x</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>23c</q><br><span><var>f, g</var><span class="hyp-type"><b>: </b><span>{y0 : {_ : nat &amp; nat}
| MR lt
    (<span class="kr">fun</span> <span class="nv">recarg</span> : {_ : nat &amp; nat} =&gt; projT2 recarg)
    y0 (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x (S y))} -&gt;
nat</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span>
  <span class="nv">y</span> : {y0 : {_ : nat &amp; nat}
      | MR lt
          (<span class="kr">fun</span> <span class="nv">recarg</span> : {_ : nat &amp; nat} =&gt;
           projT2 recarg) y0
          (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) x (S y))},
f y = g y</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">f
  (exist
     (<span class="kr">fun</span> <span class="nv">recarg&#39;</span> : {_ : nat &amp; nat} =&gt;
      projT2 recarg&#39; &lt; S y)
     (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) (S y) (x mod S y))
     (gcd_3_func_obligation_1 x (S y) (S y)
        (gcd_3_func_obligation_2 y) eq_refl)) =
g
  (exist
     (<span class="kr">fun</span> <span class="nv">recarg&#39;</span> : {_ : nat &amp; nat} =&gt;
      projT2 recarg&#39; &lt; S y)
     (existT (<span class="kr">fun</span> <span class="nv">_</span> : nat =&gt; nat) (S y) (x mod S y))
     (gcd_3_func_obligation_1 x (S y) (S y)
        (gcd_3_func_obligation_2 y) eq_refl))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>246</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">reflexivity</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>24e</q><span class="goal-separator"><hr></span><q>251</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> H.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Fact</span> <span class="nf">gcd_3_equation_2</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>,
  gcd_3 a (S b) = gcd_3 (S b) (a mod S b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : nat,
gcd_3 a (S b) = gcd_3 (S b) (a mod S b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>258</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* identical to `gcd_3_equation_1`; omitted *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span></span></pre><!-- TODO: why does `Print Assumptions gcd_3_equation_1.` not show an axiom? -->
<p>Using these reduction lemmas we can prove the correctness of <code class="highlight coq"><span class="n">gcd_3</span></code>.
Even now the proof is less elegant than with Equations.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">gcd_3_ok</span> : <span class="kr">forall</span> <span class="nv">b</span> <span class="nv">a</span>, is_gcd a b (gcd_3 a b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">b</span> <span class="nv">a</span> : nat, is_gcd a b (gcd_3 a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>25d</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">induction</span> b <span class="nb">using</span> (well_founded_induction lt_wf).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>60</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : nat,
y &lt; b -&gt; <span class="kr">forall</span> <span class="nv">a</span> : nat, is_gcd a y (gcd_3 a y)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> : nat, is_gcd a b (gcd_3 a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* Crucially, the IH is general over `a`. *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>60</q><br><q>265</q><br><q>d4</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_gcd a b (gcd_3 a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">destruct</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : nat,
y &lt; <span class="mi">0</span> -&gt; <span class="kr">forall</span> <span class="nv">a</span> : nat, is_gcd a y (gcd_3 a y)</span></span></span><br><q>d4</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_gcd a <span class="mi">0</span> (gcd_3 a <span class="mi">0</span>)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>60</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : nat,
y &lt; S b -&gt; <span class="kr">forall</span> <span class="nv">a</span> : nat, is_gcd a y (gcd_3 a y)</span></span></span><br><q>d4</q><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">is_gcd a (S b) (gcd_3 a (S b))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>26e</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> gcd_3_equation_1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>26f</q><span class="goal-separator"><hr></span><q>1d4</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> is_gcd_0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>274</q><span class="goal-separator"><hr></span><q>276</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> gcd_3_equation_2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>274</q><span class="goal-separator"><hr></span><div class="goal-conclusion">is_gcd a (S b) (gcd_3 (S b) (a mod S b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> is_gcd_step_rev.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>274</q><span class="goal-separator"><hr></span><div class="goal-conclusion">is_gcd (S b) (a mod S b) (gcd_3 (S b) (a mod S b))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>274</q><span class="goal-separator"><hr></span><div class="goal-conclusion">a mod S b &lt; S b</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto using</span> Nat.mod_upper_bound.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>In conclusion, while the definition is legible, <code class="highlight coq"><span class="kn">Program Fixpoint</span></code> fails to meet all other criteria.
It is cumbersome to work with and hence not recommended.</p>
</section>
<section id="acc-recursion">
<h3>Acc-recursion</h3>
<p>Finally, we study the method proposed by Leroy, which we call Acc-recursion.
They propose to 'go back to the basics' and perform structural recursion on the accessibility of the decreasing argument.
To understand what this means, let's look at a concrete example:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Fail</span> <span class="kn">Fixpoint</span> <span class="nf">gcd_rec</span> (<span class="nv">a</span> <span class="nv">b</span> : nat) (<span class="nv">ACC</span> : Acc lt b)
    {<span class="nv">struct</span> <span class="nv">ACC</span>} : nat :=
  <span class="kr">match</span> b <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; a
  | _ =&gt; gcd_rec b (a mod b) _
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
Cannot infer this placeholder of type
<span class="s2">&quot;Acc lt (a mod b)&quot;</span> <span class="kr">in</span>
environment:
gcd_rec : nat -&gt; <span class="kr">forall</span> <span class="nv">b</span> : nat, Acc lt b -&gt; nat
a, b : nat
ACC : Acc lt b
n : nat</blockquote></div></div></small></span></pre><p>Compared to the <a class="reference internal" href="#naive-gcd">naive definition</a>, we added an auxiliary argument: the accessibility proof <code class="highlight coq"><span class="n">ACC</span></code> of <code class="highlight coq"><span class="n">b</span></code>.
With the annotation <code class="highlight coq"><span class="o">{</span><span class="kr">struct</span> <span class="n">ACC</span><span class="o">}</span></code>, we indicate that we want to perform structural recursion on <code class="highlight coq"><span class="n">ACC</span></code>.
In the recursive call, it remains to fill the hole <code class="highlight coq"><span class="n">_</span></code> with a (transparent) proof of accessibility of <code class="highlight coq"><span class="n">a</span> <span class="n">mod</span> <span class="n">b</span></code>. This proof must be a structural subterm of <code class="highlight coq"><span class="n">ACC</span></code>.
Leroy suggests to use <code class="highlight coq"><span class="n">Acc_inv</span></code> for this.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Check</span> Acc_inv.</label><small class="alectryon-output a:show"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Acc_inv
     : <span class="kr">forall</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; A -&gt; <span class="kt">Prop</span>) (<span class="nv">x</span> : A),
       Acc R x -&gt; <span class="kr">forall</span> <span class="nv">y</span> : A, R y x -&gt; Acc R y</blockquote></div></div></small></span></pre><p>This is the inversion principle for <code class="highlight coq"><span class="n">Acc</span></code>, provided by the standard library.
Since <code class="highlight coq"><span class="n">Acc</span></code> has a single constructor, <code class="highlight coq"><span class="n">Acc</span> <span class="n">lt</span> <span class="n">b</span></code> only holds if <code class="highlight coq"><span class="n">Acc</span> <span class="n">lt</span> <span class="n">x</span></code> for all <code class="highlight coq"><span class="n">x</span></code> smaller than <code class="highlight coq"><span class="n">b</span></code>. This means we can extract an accessibility proof of <code class="highlight coq"><span class="n">a</span> <span class="n">mod</span> <span class="n">b</span></code> from <code class="highlight coq"><span class="n">Acc</span> <span class="n">lt</span> <span class="n">b</span></code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Fail</span> <span class="kn">Fixpoint</span> <span class="nf">gcd_rec</span> (<span class="nv">a</span> <span class="nv">b</span> : nat) (<span class="nv">ACC</span> : Acc lt b)
    {<span class="nv">struct</span> <span class="nv">ACC</span>} : nat :=
  <span class="kr">match</span> b <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; a
  | _ =&gt; gcd_rec b (a mod b) (Acc_inv ACC _)
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
Cannot infer this placeholder of type <span class="s2">&quot;a mod b &lt; b&quot;</span> <span class="kr">in</span>
environment:
gcd_rec : nat -&gt; <span class="kr">forall</span> <span class="nv">b</span> : nat, Acc lt b -&gt; nat
a, b : nat
ACC : Acc lt b
n : nat</blockquote></div></div></small></span></pre><p>Now, the hole requires a proof of <code class="highlight coq"><span class="n">a</span> <span class="n">mod</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">b</span></code> (and it can be opaque).
You can provide an explicit proof term, but it is easier to generate an obligation using <code class="highlight coq"><span class="n">Program</span></code>:</p>
<!-- TODO: show definition with explicit proof? -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Fixpoint</span> <span class="nf">gcd_rec</span> (<span class="nv">a</span> <span class="nv">b</span> : nat) (<span class="nv">ACC</span> : Acc lt b)
    {<span class="nv">struct</span> <span class="nv">ACC</span>} : nat :=
  <span class="kr">match</span> b <span class="kr">with</span>
  | <span class="mi">0</span> =&gt; a
  | _ =&gt; gcd_rec b (a mod b) (Acc_inv ACC _)
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Next Obligation</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1ce</q><br><span><var>ACC</var><span class="hyp-type"><b>: </b><span>Acc lt b</span></span></span><br><q>210</q><br></div><span class="goal-separator"><hr></span><q>211</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto using</span> Nat.mod_upper_bound.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- We have successfully implemented Euclid's algorithm without any plugins! -->
<p>Note that we solely use <code class="highlight coq"><span class="n">Program</span></code> to generate obligations for the holes!
This is entirely different from the previous section, where we used it to perform well-founded recursion. (Here, we simply perform structural recursion.)</p>
<p>If we extract this definition, the resulting code is flawless, since <code class="highlight coq"><span class="n">ACC</span></code> is in <code class="highlight coq"><span class="kt">Prop</span></code>, so it is discarded during extraction.</p>
<!-- 'The accessibility predicate is defined to be non-informative' -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Extraction</span> gcd_rec.</label><small class="alectryon-output a:show"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="sd">(** val gcd_rec : nat -&gt; nat -&gt; nat **)</span>

<span class="kr">let rec</span> <span class="nv">gcd_rec</span> <span class="nv">a</span> <span class="nv">b</span> = <span class="kr">match</span> b <span class="kr">with</span>
| O -&gt; a
| S _ -&gt; gcd_rec b (Nat.modulo a b)</blockquote></div></div></small></span></pre><p>Next, we want to prove the correctness.
You might be inclined to perform induction on <code class="highlight coq"><span class="n">ACC</span></code>, but Leroy warns this is not effective.
Instead, we perform well-founded induction on <code class="highlight coq"><span class="n">b</span></code>, the decreasing argument.
Then, in order to unfold <code class="highlight coq"><span class="n">gcd_rec</span></code>, we destruct <code class="highlight coq"><span class="n">ACC</span></code>.</p>
<!-- TODO: explain/show why induction on `ACC` is not effective -->
<!-- Actually, `b` is not the decreasing argument anymore (`ACC` is), but we still refer to it as such. -->
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">gcd_rec_ok</span> : <span class="kr">forall</span> <span class="nv">b</span> <span class="nv">a</span> <span class="nv">ACC</span>, is_gcd a b (gcd_rec a b ACC).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">b</span> <span class="nv">a</span> : nat) (<span class="nv">ACC</span> : Acc lt b),
is_gcd a b (gcd_rec a b ACC)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>295</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">induction</span> b <span class="nb">using</span> (well_founded_induction lt_wf).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>60</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : nat,
y &lt; b -&gt;
<span class="kr">forall</span> (<span class="nv">a</span> : nat) (<span class="nv">ACC</span> : Acc lt y),
is_gcd a y (gcd_rec a y ACC)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : nat) (<span class="nv">ACC</span> : Acc lt b),
is_gcd a b (gcd_rec a b ACC)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">destruct</span> ACC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>60</q><br><q>29d</q><br><q>d4</q><br><span><var>a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : nat, y &lt; b -&gt; Acc lt y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">is_gcd a b (gcd_rec a b (Acc_intro b a0))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>2a2</q><span class="goal-separator"><hr></span><div class="goal-conclusion">is_gcd a b
  (<span class="kr">match</span> b <span class="kr">as</span> b&#39; <span class="kr">return</span> (b&#39; = b -&gt; nat) <span class="kr">with</span>
   | <span class="mi">0</span> =&gt; <span class="kr">fun</span> <span class="nv">_</span> : <span class="mi">0</span> = b =&gt; a
   | S n =&gt;
       <span class="kr">fun</span> <span class="nv">Heq_b</span> : S n = b =&gt;
       gcd_rec b (a mod b)
         (a0 (a mod b)
            (gcd_rec_obligation_1 a b (S n)
               (gcd_rec_obligation_2 n) Heq_b))
   <span class="kr">end</span> eq_refl)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">destruct</span> b.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : nat,
y &lt; <span class="mi">0</span> -&gt;
<span class="kr">forall</span> (<span class="nv">a</span> : nat) (<span class="nv">ACC</span> : Acc lt y),
is_gcd a y (gcd_rec a y ACC)</span></span></span><br><q>d4</q><br><span><var>a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : nat, y &lt; <span class="mi">0</span> -&gt; Acc lt y</span></span></span><br></div><span class="goal-separator"><hr></span><q>1d4</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>60</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : nat,
y &lt; S b -&gt;
<span class="kr">forall</span> (<span class="nv">a</span> : nat) (<span class="nv">ACC</span> : Acc lt y),
is_gcd a y (gcd_rec a y ACC)</span></span></span><br><q>d4</q><br><span><var>a0</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : nat, y &lt; S b -&gt; Acc lt y</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">is_gcd a (S b)
  (gcd_rec (S b) (a mod S b)
     (a0 (a mod S b)
        (gcd_rec_obligation_1 a (S b) (S b)
           (gcd_rec_obligation_2 b) eq_refl)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>2ab</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> is_gcd_0.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>2b1</q><span class="goal-separator"><hr></span><q>2b4</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> is_gcd_step_rev.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>2b1</q><span class="goal-separator"><hr></span><div class="goal-conclusion">is_gcd (S b) (a mod S b)
  (gcd_rec (S b) (a mod S b)
     (a0 (a mod S b)
        (gcd_rec_obligation_1 a (S b) (S b)
           (gcd_rec_obligation_2 b) eq_refl)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>2b1</q><span class="goal-separator"><hr></span><q>28a</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto using</span> Nat.mod_upper_bound.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>The order in which we quantify over the variables is important: the induction hypothesis should be general over both <code class="highlight coq"><span class="n">a</span></code> and <code class="highlight coq"><span class="n">ACC</span></code>.
For the same reason, we should not <code class="highlight coq"><span class="nb">intros</span></code> before <code class="highlight coq"><span class="nb">induction</span></code>.</p>
<p>Even for a simple function like Euclid's algorithm, the accessibility argument in the goal becomes distractingly verbose.
A useful trick: in <a class="reference external" href="https://github.com/rocq-prover/vsrocq">VsRocq</a> for VS Code, you can Alt+Click to hide this argument in the goal. It is safe to ignore, since the induction hypothesis abstracts over <code class="highlight coq"><span class="n">ACC</span></code>. Other editors might have similar functionality.</p>
<p>Optionally, we can define a neat 'wrapper' that provides the initial accessibility proof.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">gcd_4</span> (<span class="nv">a</span> <span class="nv">b</span> : nat) : nat := gcd_rec a b (lt_wf b).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">gcd_4_ok</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span>, is_gcd a b (gcd_4 a b).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> : nat, is_gcd a b (gcd_4 a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2c2</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>1cd</q><span class="goal-separator"><hr></span><div class="goal-conclusion">is_gcd a b (gcd_4 a b)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> gcd_rec_ok.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- TODO: show we can also `Compute`? -->
<p>To conclude, let's assess the criteria.
While the extracted code is pristine (#2), our definition is less readable due to the auxiliary accessibility arguments (#1).
Proving correctness is somewhat more involved than, for example, using Equations, but nevertheless every step is easy to follow (#3).
Lastly, no axioms were required (#4).</p>
</section>
<section id="discussion">
<h3>Discussion</h3>
<p>In the table below, we summarize our experience with the four methods discussed in the preceding sections.
Here ‚úÖ, üü°, and ‚ùå denote 'good', 'adequate', and 'bad', respectively.
This mostly agrees with Leroy, except that Acc-recursion is graded üü° on the first criterion.</p>
<table>
<thead>
<tr><th class="head"><p>Criteria</p></th>
<th class="head"><p>Function</p></th>
<th class="head"><p>Equations</p></th>
<th class="head"><p>Program Fixpoint</p></th>
<th class="head"><p>Acc-recursion</p></th>
</tr>
</thead>
<tbody>
<tr><td><p>Legibility of definitions</p></td>
<td><p>‚úÖ</p></td>
<td><p>‚úÖ</p></td>
<td><p>‚úÖ</p></td>
<td><p>üü°</p></td>
</tr>
<tr><td><p>Legibility of extracted code</p></td>
<td><p>‚úÖ</p></td>
<td><p>‚ùå</p></td>
<td><p>‚ùå</p></td>
<td><p>‚úÖ</p></td>
</tr>
<tr><td><p>Ease of proving properties</p></td>
<td><p>‚úÖ</p></td>
<td><p>‚úÖ</p></td>
<td><p>‚ùå</p></td>
<td><p>‚úÖ</p></td>
</tr>
<tr><td><p>No axioms used</p></td>
<td><p>‚úÖ</p></td>
<td><p>‚úÖ</p></td>
<td><p>‚ùå</p></td>
<td><p>‚úÖ</p></td>
</tr>
</tbody>
</table>
<p>Leroy mentions two more approaches to perform well-founded recursion: tactics in proof mode and the <code class="highlight coq"><span class="n">Fix</span></code> combinator.
We did not study these since they are clearly inferior to the other four methods.
Both approaches are lower-level than, for example, Equations, and hence are generally harder to work with. Specifically, both methods suffer from poorly legible definitions and <code class="highlight coq"><span class="n">Fix</span></code>, like <code class="highlight coq"><span class="kn">Program Fixpoint</span></code>, requires axioms.</p>
<!-- http://adam.chlipala.net/cpdt/html/Cpdt.GeneralRec.html -->
<p>In addition to the four criteria in the table, we could consider a fifth: <em>understandability</em>.
Function and Equations are powerful plugins with a user-friendly interface, but it can be difficult to grasp what happens inside the 'black box'.
On the other hand, Acc-recursion relies on more basic principles, making it easy to understand. The latter is especially valuable in educational contexts.</p>
<p>Our recommendations are as follows.
If code extraction is not a requirement, use Equations. It functions similarly to Function, but is more modern.
Otherwise, Acc-recursion offers more transparency and control.</p>
<p>In the remainder of this tutorial, we will apply Acc-recursion to two other problems: quicksort (on lists) and a rebalancing algorithm (on trees).
These will serve as examples of how the method performs on more complicated inductive data structures.</p>
<!-- Leroy presents two more examples as well: Tarski iteration and depth-first search on acyclic graphs. -->
<!-- Leroy assumes b <= a, but this is not necessary and we simplified this. -->
</section>
</section>
<section id="quicksort">
<h2>Quicksort</h2>
<p>We have seen how Acc-recursion can be used to implement Euclid's algorithm.
Now, we want to evaluate how well this method performs on more complex algorithms and data structures.
To this end, we will study a widely used algorithm on lists: <em>quicksort</em>.
For simplicity, we restrict ourselves to lists on natural numbers.
Naively, we might implement quicksort as follows.</p>
<span class="target" id="naive-qs"></span><pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">geb</span> (<span class="nv">x</span> <span class="nv">y</span> : nat) := Nat.leb y x.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input alectryon-failed"><span class="kn">Fixpoint</span> <span class="nf">quicksort</span> (<span class="nv">l</span> : list nat) :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; []
  | x :: xs =&gt;
      <span class="kr">let</span> <span class="nv">L</span> := filter (    geb x) xs <span class="kr">in</span>
      <span class="kr">let</span> <span class="nv">R</span> := filter (Nat.ltb x) xs <span class="kr">in</span>
      quicksort L ++ x :: quicksort R
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">Recursive definition of quicksort <span class="kr">is</span> ill-formed.
In environment
quicksort : list nat -&gt; list nat
l : list nat
x : nat
xs : list nat
L := filter (geb x) xs : list nat
R := filter (Nat.ltb x) xs : list nat
Recursive call to quicksort has principal argument
equal to <span class="s2">&quot;R&quot;</span> instead of <span class="s2">&quot;xs&quot;</span>.
Recursive definition <span class="kr">is</span>:
<span class="s2">&quot;fun l : list nat =&gt;</span>
<span class="s2"> match l with</span>
<span class="s2"> | [] =&gt; []</span>
<span class="s2"> | x :: xs =&gt;</span>
<span class="s2">     let L := filter (geb x) xs in</span>
<span class="s2">     let R := filter (Nat.ltb x) xs in</span>
<span class="s2">     quicksort L ++ x :: quicksort R</span>
<span class="s2"> end&quot;</span>.</blockquote></div></div></small></span></pre><p>However, <code class="highlight coq"><span class="n">L</span></code> and <code class="highlight coq"><span class="n">R</span></code> are not structural subterms of <code class="highlight coq"><span class="n">l</span></code>, so this definition is rejected.
Nevertheless, <code class="highlight coq"><span class="n">quicksort</span></code> terminates, since <code class="highlight coq"><span class="n">L</span></code> and <code class="highlight coq"><span class="n">R</span></code> are shorter than <code class="highlight coq"><span class="n">l</span></code> as they never contain the pivot <code class="highlight coq"><span class="n">x</span></code>. We will formalize this using well-founded recursion.</p>
<p>In contrast to Euclid's algorithm, which we implemented using Acc-recursion without much groundwork, we will now systematically derive a definition of quicksort.
To this end, the next section presents a practical, general guide on using Acc-recursion.</p>
<section id="guide-to-acc-recursion">
<h3>Guide to Acc-recursion</h3>
<p>We have applied Acc-recursion to one concrete problem so far, but it is helpful to distill the method into a <em>design pattern</em> applicable to arbitrary algorithms.
That is the goal of this section.</p>
<p>For <code class="highlight coq"><span class="n">gcd</span></code>, we started with the naive definition and gradually added accessibility arguments. This is a practical approach in general.
However, in hindsight, we can improve our approach to managing the obligations.
You may have noticed that we often wrote <code class="highlight coq"><span class="nb">auto using</span> <span class="n">Nat</span><span class="o">.</span><span class="n">mod_upper_bound</span></code>, not only to prove the obligations, but also after applying the induction hypothesis. This is no coincidence.
Since these obligations are typically simple, we suggest to prove them as separate lemmas and add them to a hint database.
Then, after applying the induction hypothesis, proofs can simply be finished with <code class="highlight coq"><span class="nb">auto</span></code>. Furthermore, obligations will be automatically solved by the <a class="reference external" href="https://rocq-prover.org/doc/V8.20.1/refman/addendum/program.html#coq:cmd.Obligation-Tactic">default solving tactic</a>.</p>
<p>Now, combining our approach for <code class="highlight coq"><span class="n">gcd</span></code> and the above insight, we suggest the following steps to define a well-founded recursive function:</p>
<ol class="arabic simple">
<li><p>Write the naive <code class="highlight coq"><span class="kn">Fixpoint</span></code> definition.</p></li>
<li><p>Determine the decreasing argument, say <code class="highlight coq"><span class="n">x</span></code>, and the relation, say <code class="highlight coq"><span class="n">R</span></code>, such that <code class="highlight coq"><span class="n">x</span></code> decreases according to <code class="highlight coq"><span class="n">R</span></code> each recursive call.</p></li>
<li><p>Add an auxiliary argument <code class="highlight coq"><span class="n">ACC</span> <span class="o">:</span> <span class="n">Acc</span> <span class="n">R</span> <span class="n">x</span></code> to the function signature, and add an argument <code class="highlight coq"><span class="n">Acc_inv</span> <span class="n">ACC</span> <span class="n">_</span></code> to each recursive call. Also, change <code class="highlight coq"><span class="kn">Fixpoint</span></code> into <code class="highlight coq"><span class="kn">Program Fixpoint</span></code>.</p></li>
<li><p>Now, obligations should be generated. For each goal, create a new lemma. Prove these lemmas and add them to a hint database. It is easiest if you add them to <code class="highlight coq"><span class="n">core</span></code>. Otherwise, you will have to customize the obligation solving tactic.</p></li>
<li><p>Then, all obligations should be automatically solved. Check that your function definition is accepted.</p></li>
</ol>
<p>In the end, we have a valid definition that is structurally recursive in the <code class="highlight coq"><span class="n">ACC</span></code> argument.
You can make this explicit using a <code class="highlight coq"><span class="o">{</span><span class="kr">struct</span> <span class="n">ACC</span><span class="o">}</span></code> annotation, but this is not necessary since it can be determined automatically.</p>
<p>Next, to prove properties about our new definition, we will perform well-founded induction on the decreasing argument <code class="highlight coq"><span class="n">x</span></code>. This requires the well-founded induction principle for <code class="highlight coq"><span class="n">R</span></code>, which in turn requires a proof that <code class="highlight coq"><span class="n">R</span></code> is well-founded.
If <code class="highlight coq"><span class="n">R</span></code> is a relation that compares elements via some mapping <code class="highlight coq"><span class="n">f</span> <span class="o">:</span> <span class="n">A</span> <span class="o">-&gt;</span> <span class="n">nat</span></code>, a proof of well-foundedness is provided by the theorem <code class="highlight coq"><span class="n">well_founded_ltof</span></code>. Otherwise, you need to prove it manually.</p>
<p>To prove a property, proceed as follows:</p>
<ol class="arabic simple">
<li><p>State the lemma as you would for the naive definition.</p></li>
<li><p>Add the quantifier <code class="highlight coq"><span class="kr">forall</span> <span class="nv">ACC</span></code> and add the <code class="highlight coq"><span class="n">ACC</span></code> argument where necessary. Make sure <code class="highlight coq"><span class="n">ACC</span></code> is the last variable in the quantifier list.</p></li>
<li><p>Start the proof with <code class="highlight coq"><span class="nb">induction</span> <span class="n">x</span> <span class="nb">using</span> <span class="o">(</span><span class="n">well_founded_induction</span> <span class="o">&lt;</span><span class="n">proof</span><span class="o">&gt;)</span></code>. That is, perform well-founded induction on the decreasing argument <code class="highlight coq"><span class="n">x</span></code> using the well-foundedness of <code class="highlight coq"><span class="n">R</span></code>.</p></li>
<li><p>Next, <code class="highlight coq"><span class="nb">destruct</span> <span class="n">ACC</span></code>. Now, with <code class="highlight coq"><span class="nb">simpl</span></code>, you can unroll your function.</p></li>
<li><p>Proceed as normal. Since your function likely matches on the decreasing argument, the logical next step is <code class="highlight coq"><span class="nb">destruct</span> <span class="n">x</span></code>.</p></li>
</ol>
<!-- TODO: when and when not to `intros`? -->
<p>At some point in the proof, you will apply the induction hypothesis.
Then, you must show that the argument it is applied to is smaller than the original <code class="highlight coq"><span class="n">x</span></code> under <code class="highlight coq"><span class="n">R</span></code>. If your proof follows the structure of the definition, the proof goal will precisely match an obligation. Since we added these as hints, <code class="highlight coq"><span class="nb">auto</span></code> can solve them directly.</p>
<p>In the remainder of this section, we will carry out these steps to implement and prove the correctness of quicksort.
Before reading on, it is highly instructive to fix the naive definition of quicksort yourself using this guide, and prove a simple property about it.</p>
</section>
<section id="implementation">
<h3>Implementation</h3>
<p>Now, we will formulate a well-founded recursive definition of quicksort.
Since we already provided a <a class="reference internal" href="#naive-qs">naive definition</a>, we move on to step 2.
The list becomes shorter every recursive call, so the relation should compare lists by length.
It can be conveniently defined through <code class="highlight coq"><span class="n">ltof</span></code> (see <a class="reference internal" href="#well-founded-induction">Well-founded induction</a>).</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">lt_len</span>     := ltof              _ (@length nat).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">lt_len_wf</span>  := well_founded_ltof _ (@length nat).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">wf_ind_len</span> := well_founded_induction lt_len_wf.</span></span></pre><p>We also immediately derive the well-foundedness (<code class="highlight coq"><span class="n">lt_len_wf</span></code>) and the induction principle (<code class="highlight coq"><span class="n">wf_ind_len</span></code>) for later use.
Note that <code class="highlight coq"><span class="o">&#64;</span></code> makes all implicit arguments explicit, allowing us to specialize <code class="highlight coq"><span class="n">lt_len</span></code> to lists of natural numbers.</p>
<p>Next, we skip to step 4. You are encouraged to carry out step 3 yourself, and check if <code class="highlight coq"><span class="n">qs_oblig</span></code> is sensible.
The proof obligation generated by <code class="highlight coq"><span class="kn">Program Fixpoint</span></code> will actually be in terms of <code class="highlight coq"><span class="n">lt_len</span></code>, but we state <code class="highlight coq"><span class="n">qs_oblig</span></code> in its 'unfolded' form. This makes the hint applicable even if the goal is already (partially) unfolded.
To ensure the obligations are still solved automatically, we allow <code class="highlight coq"><span class="n">lt_len</span></code> and <code class="highlight coq"><span class="n">ltof</span></code> to be unfolded by <code class="highlight coq"><span class="nb">auto</span></code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Fact</span> <span class="nf">qs_oblig</span> : <span class="kr">forall</span> <span class="nv">f</span> (<span class="nv">x</span> : nat) <span class="nv">xs</span>,
  length (filter f xs) &lt; length (x :: xs).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : nat -&gt; bool) (<span class="nv">x</span> : nat) (<span class="nv">xs</span> : list nat),
length (filter f xs) &lt; length (x :: xs)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2cc</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>f</var><span class="hyp-type"><b>: </b><span>nat -&gt; bool</span></span></span><br><q>141</q><br><span><var>xs</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">length (filter f xs) &lt; length (x :: xs)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>2d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">length (filter f xs) &lt; S (length xs)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> Nat.lt_succ_r.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>2d3</q><span class="goal-separator"><hr></span><div class="goal-conclusion">length (filter f xs) &lt;= length xs</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> filter_length_le.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hint Unfold</span> lt_len ltof : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hint Resolve</span> qs_oblig : core.</span></span></pre><p>Then, combining steps 3 and 5, we see that all obligations of the definition with auxiliary arguments are solved automatically:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Fixpoint</span> <span class="nf">qs_rec</span> (<span class="nv">l</span> : list nat) (<span class="nv">ACC</span> : Acc lt_len l) :=
  <span class="kr">match</span> l <span class="kr">with</span>
  | [] =&gt; []
  | x :: xs =&gt;
      <span class="kr">let</span> <span class="nv">L</span> := filter (    geb x) xs <span class="kr">in</span>
      <span class="kr">let</span> <span class="nv">R</span> := filter (Nat.ltb x) xs <span class="kr">in</span>
      qs_rec L (Acc_inv ACC _) ++ x :: qs_rec R (Acc_inv ACC _)
  <span class="kr">end</span>.</span></span></pre><p>Now, we are ready to prove that <code class="highlight coq"><span class="n">qs_rec</span></code> is correct.
The correctness comprises two aspects: the resulting list is sorted and contains the same elements.
It is interesting and non-trivial to formalize these notions, but we take a practical approach and use the definitions of <a class="reference external" href="https://rocq-prover.org/doc/V8.20.1/stdlib/Coq.Sorting.Permutation.html">sortedness</a> and <a class="reference external" href="https://rocq-prover.org/doc/V8.20.1/stdlib/Coq.Sorting.Sorted.html">permutations</a> from the standard library.</p>
</section>
<section id="permutation">
<h3>Permutation</h3>
<p>First, we will show that a quicksorted list is a permutation of the original list.
For the naive definition, the lemma would be stated as follows (step 1).</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Permutation.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Print</span> Permutation.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Inductive</span>
<span class="nf">Permutation</span> (<span class="nv">A</span> : <span class="kt">Type</span>) : list A -&gt; list A -&gt; <span class="kt">Prop</span> :=
    perm_nil : Permutation [] []
  | perm_skip : <span class="kr">forall</span> (<span class="nv">x</span> : A) (<span class="nv">l</span> <span class="nv">l&#39;</span> : list A),
                Permutation l l&#39; -&gt;
                Permutation (x :: l) (x :: l&#39;)
  | perm_swap : <span class="kr">forall</span> (<span class="nv">x</span> <span class="nv">y</span> : A) (<span class="nv">l</span> : list A),
                Permutation (y :: x :: l)
                  (x :: y :: l)
  | perm_trans : <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">l&#39;</span> <span class="nv">l&#39;&#39;</span> : list A,
                 Permutation l l&#39; -&gt;
                 Permutation l&#39; l&#39;&#39; -&gt;
                 Permutation l l&#39;&#39;.

<span class="kn">Arguments</span> Permutation [A]%type_scope (_ _)%list_scope
<span class="kn">Arguments</span> perm_nil A%type_scope
<span class="kn">Arguments</span> perm_skip [A]%type_scope x [l l&#39;]%list_scope
  _
<span class="kn">Arguments</span> perm_swap [A]%type_scope x y l%list_scope
<span class="kn">Arguments</span> perm_trans [A]%type_scope
  [l l&#39; l&#39;&#39;]%list_scope _ _</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Fail</span> <span class="kn">Lemma</span> <span class="nf">qs_Permutation</span> : <span class="kr">forall</span> <span class="nv">l</span>, Permutation l (qs_rec l).</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
In environment
l : list nat
The term <span class="s2">&quot;qs_rec l&quot;</span> has type
 <span class="s2">&quot;Acc lt_len l -&gt; list nat&quot;</span>
while it <span class="kr">is</span> expected to <span class="nb">have</span> type <span class="s2">&quot;list nat&quot;</span>.</blockquote></div></div></small></span></pre><p>Of course, <code class="highlight coq"><span class="n">qs_rec</span></code> takes an <code class="highlight coq"><span class="n">ACC</span></code> argument, so we add it to the quantifier list (step 2).
Now, try to prove this revised lemma. The setup for well-founded induction is already given. A helper lemma, <code class="highlight coq"><span class="n">partition_Permutation</span></code>, may be useful.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">partition_Permutation</span> : <span class="kr">forall</span> <span class="nv">p</span> <span class="nv">xs</span>,
  Permutation xs (filter (geb p) xs ++ filter (Nat.ltb p) xs).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">p</span> : nat) (<span class="nv">xs</span> : list nat),
Permutation xs
  (filter (geb p) xs ++ filter (Nat.ltb p) xs)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>2e2</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">induction</span> xs <span class="kr">as</span> [| x xs IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Permutation []
  (filter (geb p) [] ++ filter (Nat.ltb p) [])</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>p, x</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><q>2d5</q><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>Permutation xs
  (filter (geb p) xs ++ filter (Nat.ltb p) xs)</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">Permutation (x :: xs)
  (filter (geb p) (x :: xs) ++
   filter (Nat.ltb p) (x :: xs))</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">trivial</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>2ee</q><span class="goal-separator"><hr></span><q>2f1</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">unfold</span> geb.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>2ee</q><span class="goal-separator"><hr></span><div class="goal-conclusion">Permutation (x :: xs)
  (filter (<span class="kr">fun</span> <span class="nv">y</span> : nat =&gt; y &lt;=? p) (x :: xs) ++
   filter (Nat.ltb p) (x :: xs))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>2ee</q><span class="goal-separator"><hr></span><div class="goal-conclusion">Permutation (x :: xs)
  ((<span class="kr">if</span> x &lt;=? p
    <span class="kr">then</span> x :: filter (<span class="kr">fun</span> <span class="nv">y</span> : nat =&gt; y &lt;=? p) xs
    <span class="kr">else</span> filter (<span class="kr">fun</span> <span class="nv">y</span> : nat =&gt; y &lt;=? p) xs) ++
   (<span class="kr">if</span> p &lt;? x
    <span class="kr">then</span> x :: filter (Nat.ltb p) xs
    <span class="kr">else</span> filter (Nat.ltb p) xs))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">destruct</span> (Nat.leb_spec x p).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2ef</q><br><q>2d5</q><br><q>2f0</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span>x &lt;= p</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Permutation (x :: xs)
  ((x :: filter (<span class="kr">fun</span> <span class="nv">y</span> : nat =&gt; y &lt;=? p) xs) ++
   (<span class="kr">if</span> p &lt;? x
    <span class="kr">then</span> x :: filter (Nat.ltb p) xs
    <span class="kr">else</span> filter (Nat.ltb p) xs))</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2ef</q><br><q>2d5</q><br><q>2f0</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span>p &lt; x</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">Permutation (x :: xs)
  (filter (<span class="kr">fun</span> <span class="nv">y</span> : nat =&gt; y &lt;=? p) xs ++
   (<span class="kr">if</span> p &lt;? x
    <span class="kr">then</span> x :: filter (Nat.ltb p) xs
    <span class="kr">else</span> filter (Nat.ltb p) xs))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>2ff</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> Nat.ltb_ge <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2ef</q><br><q>2d5</q><br><q>2f0</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(p &lt;? x) = false</span></span></span><br></div><span class="goal-separator"><hr></span><q>302</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>30d</q><span class="goal-separator"><hr></span><div class="goal-conclusion">Permutation (x :: xs)
  ((x :: filter (<span class="kr">fun</span> <span class="nv">y</span> : nat =&gt; y &lt;=? p) xs) ++
   filter (Nat.ltb p) xs)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>30d</q><span class="goal-separator"><hr></span><div class="goal-conclusion">Permutation (x :: xs)
  (x
   :: filter (<span class="kr">fun</span> <span class="nv">y</span> : nat =&gt; y &lt;=? p) xs ++
      filter (Nat.ltb p) xs)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>30d</q><span class="goal-separator"><hr></span><div class="goal-conclusion">Permutation xs
  (filter (<span class="kr">fun</span> <span class="nv">y</span> : nat =&gt; y &lt;=? p) xs ++
   filter (Nat.ltb p) xs)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>305</q><span class="goal-separator"><hr></span><q>307</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> Nat.ltb_lt <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2ef</q><br><q>2d5</q><br><q>2f0</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span>(p &lt;? x) = true</span></span></span><br></div><span class="goal-separator"><hr></span><q>307</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">rewrite</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>321</q><span class="goal-separator"><hr></span><div class="goal-conclusion">Permutation (x :: xs)
  (filter (<span class="kr">fun</span> <span class="nv">y</span> : nat =&gt; y &lt;=? p) xs ++
   x :: filter (Nat.ltb p) xs)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> Permutation_cons_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>321</q><span class="goal-separator"><hr></span><q>31a</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">qs_Permutation</span> : <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">ACC</span>, Permutation l (qs_rec l ACC).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list nat) (<span class="nv">ACC</span> : Acc lt_len l),
Permutation l (qs_rec l ACC)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>32b</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">induction</span> l <span class="kr">as</span> [l IH] <span class="nb">using</span> wf_ind_len.       <span class="c">(* step 3 *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>l</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
ltof (list nat) (length (A:=nat)) y l -&gt;
<span class="kr">forall</span> <span class="nv">ACC</span> : Acc lt_len y,
Permutation y (qs_rec y ACC)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ACC</span> : Acc lt_len l,
Permutation l (qs_rec l ACC)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">destruct</span> ACC.                                 <span class="c">(* step 4 *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>333</q><br><q>334</q><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat, lt_len y l -&gt; Acc lt_len y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Permutation l (qs_rec l (Acc_intro l a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">destruct</span> l.                                   <span class="c">(* step 5 *)</span></label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
ltof (list nat) (length (A:=nat)) y [] -&gt;
<span class="kr">forall</span> <span class="nv">ACC</span> : Acc lt_len y,
Permutation y (qs_rec y ACC)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat, lt_len y [] -&gt; Acc lt_len y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Permutation [] (qs_rec [] (Acc_intro [] a))</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2a</q><br><q>333</q><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
ltof (list nat) (length (A:=nat)) y (n :: l) -&gt;
<span class="kr">forall</span> <span class="nv">ACC</span> : Acc lt_len y,
Permutation y (qs_rec y ACC)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
lt_len y (n :: l) -&gt; Acc lt_len y</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">Permutation (n :: l)
  (qs_rec (n :: l) (Acc_intro (n :: l) a))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* exercise *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span></span></pre></section>
<section id="sorted">
<h3>Sorted</h3>
<p>Proving that a quicksorted list is indeed sorted is more involved.
There are two notions of sortedness in the standard library: locally sorted and strongly sorted.
Since <code class="highlight coq"><span class="o">&lt;</span></code> is a transitive relation, they are actually equivalent, but we will use <code class="highlight coq"><span class="n">StronglySorted</span></code> since it allows convenient use of, e.g., <code class="highlight coq"><span class="n">Forall_app</span></code> in <code class="highlight coq"><span class="n">Sorted_app</span></code> below.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Sorted.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Print</span> StronglySorted.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="kn">Inductive</span>
<span class="nf">StronglySorted</span> (<span class="nv">A</span> : <span class="kt">Type</span>) (<span class="nv">R</span> : A -&gt; A -&gt; <span class="kt">Prop</span>)
  : list A -&gt; <span class="kt">Prop</span> :=
    SSorted_nil : StronglySorted R []
  | SSorted_cons : <span class="kr">forall</span> (<span class="nv">a</span> : A) (<span class="nv">l</span> : list A),
                   StronglySorted R l -&gt;
                   Forall (R a) l -&gt;
                   StronglySorted R (a :: l).

<span class="kn">Arguments</span> StronglySorted [A]%type_scope
  R%function_scope _%list_scope
<span class="kn">Arguments</span> SSorted_nil [A]%type_scope R%function_scope
<span class="kn">Arguments</span> SSorted_cons [A]%type_scope
  [R]%function_scope a [l]%list_scope _ _</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">Sorted</span> := StronglySorted le.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">Sorted_app</span> : <span class="kr">forall</span> <span class="nv">xs</span> <span class="nv">ys</span>,
  Sorted xs -&gt;
  Sorted ys -&gt;
  (<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span>, In x xs -&gt; In y ys -&gt; x &lt;= y) -&gt;
  Sorted (xs ++ ys).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">xs</span> <span class="nv">ys</span> : list nat,
Sorted xs -&gt;
Sorted ys -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : nat, In x xs -&gt; In y ys -&gt; x &lt;= y) -&gt;
Sorted (xs ++ ys)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>34b</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span> xs ys Hxs Hys H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>xs, ys</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>Sorted xs</span></span></span><br><span><var>Hys</var><span class="hyp-type"><b>: </b><span>Sorted ys</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : nat, In x xs -&gt; In y ys -&gt; x &lt;= y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Sorted (xs ++ ys)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">induction</span> xs <span class="kr">as</span> [| x xs IH].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>ys</var><span class="hyp-type"><b>: </b><span>list nat</span></span></span><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>Sorted []</span></span></span><br><q>355</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : nat, In x [] -&gt; In y ys -&gt; x &lt;= y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Sorted ([] ++ ys)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>141</q><br><q>353</q><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>Sorted (x :: xs)</span></span></span><br><q>355</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">x0</span> <span class="nv">y</span> : nat,
In x0 (x :: xs) -&gt; In y ys -&gt; x0 &lt;= y</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span>Sorted xs -&gt;
(<span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : nat, In x xs -&gt; In y ys -&gt; x &lt;= y) -&gt;
Sorted (xs ++ ys)</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">Sorted ((x :: xs) ++ ys)</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">trivial</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>362</q><span class="goal-separator"><hr></span><q>366</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> StronglySorted_inv <span class="kr">in</span> Hxs.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>141</q><br><q>353</q><br><span><var>Hxs</var><span class="hyp-type"><b>: </b><span>StronglySorted le xs /\ Forall (le x) xs</span></span></span><br><q>355</q><br><q>364</q><br><q>365</q><br></div><span class="goal-separator"><hr></span><q>366</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>36d</q><span class="goal-separator"><hr></span><div class="goal-conclusion">Sorted (x :: xs ++ ys)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>36d</q><span class="goal-separator"><hr></span><div class="goal-conclusion">StronglySorted le (xs ++ ys)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>36d</q><label class="goal-separator"><hr></label><div class="goal-conclusion">Forall (le x) (xs ++ ys)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>375</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> IH;
    <span class="nb">firstorder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>36d</q><span class="goal-separator"><hr></span><q>379</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> Forall_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>36d</q><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (le x) xs /\ Forall (le x) ys</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>36d</q><span class="goal-separator"><hr></span><div class="goal-conclusion">Forall (le x) xs</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>36d</q><label class="goal-separator"><hr></label><div class="goal-conclusion">Forall (le x) ys</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>385</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input">+</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>36d</q><span class="goal-separator"><hr></span><q>389</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> Forall_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>36d</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x0</span> : nat, In x0 ys -&gt; x &lt;= x0</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span> y.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>141</q><br><q>353</q><br><q>36e</q><br><q>355</q><br><q>364</q><br><q>365</q><br><span><var>y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In y ys -&gt; x &lt;= y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>396</q><span class="goal-separator"><hr></span><div class="goal-conclusion">In x (x :: xs)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">      </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> in_eq.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Next, with the goal of proving <code class="highlight coq"><span class="n">qs_Sorted</span></code>, it is helpful to show that quicksort preserves membership: any element in the output is also in the input list.
This is formalized by <code class="highlight coq"><span class="n">qs_In</span></code>. It follows easily from <code class="highlight coq"><span class="n">qs_Permutation</span></code>, but, as an exercise, you can also prove it directly using well-founded induction on <code class="highlight coq"><span class="n">l</span></code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">qs_In</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">l</span> <span class="nv">ACC</span>, In a (qs_rec l ACC) -&gt; In a l.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> : nat) (<span class="nv">l</span> : list nat) (<span class="nv">ACC</span> : Acc lt_len l),
In a (qs_rec l ACC) -&gt; In a l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>39e</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>d4</q><br><q>333</q><br><span><var>ACC</var><span class="hyp-type"><b>: </b><span>Acc lt_len l</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In a (qs_rec l ACC)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">In a l</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> Permutation_in <span class="kr">with</span> (qs_rec l ACC).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3a5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">Permutation (qs_rec l ACC) l</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>3a5</q><label class="goal-separator"><hr></label><div class="goal-conclusion">In a (qs_rec l ACC)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>3ab</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">symmetry</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3a5</q><span class="goal-separator"><hr></span><div class="goal-conclusion">Permutation l (qs_rec l ACC)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> qs_Permutation.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3a5</q><span class="goal-separator"><hr></span><q>3af</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">qs_filter_In</span> : <span class="kr">forall</span> <span class="nv">f</span> <span class="nv">a</span> <span class="nv">l</span> <span class="nv">ACC</span>,
  In a (qs_rec (filter f l) ACC) -&gt; f a = true.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">f</span> : nat -&gt; bool) (<span class="nv">a</span> : nat) (<span class="nv">l</span> : list nat)
  (<span class="nv">ACC</span> : Acc lt_len (filter f l)),
In a (qs_rec (filter f l) ACC) -&gt; f a = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3ba</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2d4</q><br><q>d4</q><br><q>333</q><br><span><var>ACC</var><span class="hyp-type"><b>: </b><span>Acc lt_len (filter f l)</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In a (qs_rec (filter f l) ACC)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">f a = true</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> qs_In <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2d4</q><br><q>d4</q><br><q>333</q><br><q>3c2</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In a (filter f l)</span></span></span><br></div><span class="goal-separator"><hr></span><q>3c4</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> filter_In <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2d4</q><br><q>d4</q><br><q>333</q><br><q>3c2</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In a l /\ f a = true</span></span></span><br></div><span class="goal-separator"><hr></span><q>3c4</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">easy</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">qs_Sorted</span> : <span class="kr">forall</span> <span class="nv">l</span> <span class="nv">ACC</span>, Sorted (qs_rec l ACC).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">l</span> : list nat) (<span class="nv">ACC</span> : Acc lt_len l),
Sorted (qs_rec l ACC)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>3d0</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">induction</span> l <span class="kr">as</span> [l IH] <span class="nb">using</span> wf_ind_len.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>333</q><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
ltof (list nat) (length (A:=nat)) y l -&gt;
<span class="kr">forall</span> <span class="nv">ACC</span> : Acc lt_len y, Sorted (qs_rec y ACC)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ACC</span> : Acc lt_len l, Sorted (qs_rec l ACC)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">destruct</span> ACC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>333</q><br><q>3d8</q><br><q>33a</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Sorted (qs_rec l (Acc_intro l a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">destruct</span> l <span class="kr">as</span> [| p l].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
ltof (list nat) (length (A:=nat)) y [] -&gt;
<span class="kr">forall</span> <span class="nv">ACC</span> : Acc lt_len y, Sorted (qs_rec y ACC)</span></span></span><br><q>341</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Sorted (qs_rec [] (Acc_intro [] a))</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2ea</q><br><q>333</q><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
ltof (list nat) (length (A:=nat)) y (p :: l) -&gt;
<span class="kr">forall</span> <span class="nv">ACC</span> : Acc lt_len y, Sorted (qs_rec y ACC)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : list nat,
lt_len y (p :: l) -&gt; Acc lt_len y</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">Sorted (qs_rec (p :: l) (Acc_intro (p :: l) a))</div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3e7</q><span class="goal-separator"><hr></span><q>3ea</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3e7</q><span class="goal-separator"><hr></span><div class="goal-conclusion">Sorted
  (qs_rec (filter (geb p) l)
     (a (filter (geb p) l) (qs_oblig (geb p) p l)) ++
   p
   :: qs_rec (filter (Nat.ltb p) l)
        (a (filter (Nat.ltb p) l)
           (qs_oblig (Nat.ltb p) p l)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> Sorted_app.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3e7</q><span class="goal-separator"><hr></span><div class="goal-conclusion">Sorted
  (qs_rec (filter (geb p) l)
     (a (filter (geb p) l) (qs_oblig (geb p) p l)))</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>3e7</q><label class="goal-separator"><hr></label><div class="goal-conclusion">Sorted
  (p
   :: qs_rec (filter (Nat.ltb p) l)
        (a (filter (Nat.ltb p) l)
           (qs_oblig (Nat.ltb p) p l)))</div></blockquote><blockquote class="alectryon-goal"><q>3e7</q><label class="goal-separator"><hr></label><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> <span class="nv">y</span> : nat,
In x
  (qs_rec (filter (geb p) l)
     (a (filter (geb p) l) (qs_oblig (geb p) p l))) -&gt;
In y
  (p
   :: qs_rec (filter (Nat.ltb p) l)
        (a (filter (Nat.ltb p) l)
           (qs_oblig (Nat.ltb p) p l))) -&gt; x &lt;= y</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="mi">2</span>: <span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>3f4</q><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>3e7</q><label class="goal-separator"><hr></label><div class="goal-conclusion">StronglySorted le
  (qs_rec (filter (Nat.ltb p) l)
     (a (filter (Nat.ltb p) l)
        (qs_oblig (Nat.ltb p) p l)))</div></blockquote><blockquote class="alectryon-goal"><q>3e7</q><label class="goal-separator"><hr></label><div class="goal-conclusion">Forall (le p)
  (qs_rec (filter (Nat.ltb p) l)
     (a (filter (Nat.ltb p) l)
        (qs_oblig (Nat.ltb p) p l)))</div></blockquote><q>3f9</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>3f4</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3e7</q><span class="goal-separator"><hr></span><div class="goal-conclusion">ltof (list nat) (length (A:=nat)) (filter (geb p) l)
  (p :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3e7</q><span class="goal-separator"><hr></span><q>3ff</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3e7</q><span class="goal-separator"><hr></span><div class="goal-conclusion">ltof (list nat) (length (A:=nat))
  (filter (Nat.ltb p) l) (p :: l)</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3e7</q><span class="goal-separator"><hr></span><q>401</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> Forall_forall.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3e7</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : nat,
In x
  (qs_rec (filter (Nat.ltb p) l)
     (a (filter (Nat.ltb p) l)
        (qs_oblig (Nat.ltb p) p l))) -&gt; p &lt;= x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2ea</q><br><q>333</q><br><q>3e8</q><br><q>3e9</q><br><q>141</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span>In x
  (qs_rec (filter (Nat.ltb p) l)
     (a (filter (Nat.ltb p) l)
        (qs_oblig (Nat.ltb p) p l)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">p &lt;= x</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> qs_filter_In, Nat.ltb_lt <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2ea</q><br><q>333</q><br><q>3e8</q><br><q>3e9</q><br><q>141</q><br><q>306</q><br></div><span class="goal-separator"><hr></span><q>41b</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>3e7</q><span class="goal-separator"><hr></span><q>3fa</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span> x y HL HR.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2ea</q><br><q>333</q><br><q>3e8</q><br><q>3e9</q><br><span><var>x, y</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>HL</var><span class="hyp-type"><b>: </b><span>In x
  (qs_rec (filter (geb p) l)
     (a (filter (geb p) l) (qs_oblig (geb p) p l)))</span></span></span><br><span><var>HR</var><span class="hyp-type"><b>: </b><span>In y
  (p
   :: qs_rec (filter (Nat.ltb p) l)
        (a (filter (Nat.ltb p) l)
           (qs_oblig (Nat.ltb p) p l)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">x &lt;= y</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> qs_filter_In, Nat.leb_le <span class="kr">in</span> HL.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2ea</q><br><q>333</q><br><q>3e8</q><br><q>3e9</q><br><q>427</q><br><span><var>HL</var><span class="hyp-type"><b>: </b><span>x &lt;= p</span></span></span><br><q>429</q><br></div><span class="goal-separator"><hr></span><q>42a</q></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">destruct</span> HR <span class="kr">as</span> [Hp | HR].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2ea</q><br><q>333</q><br><q>3e8</q><br><q>3e9</q><br><q>427</q><br><q>42f</q><br><span><var>Hp</var><span class="hyp-type"><b>: </b><span>p = y</span></span></span><br></div><span class="goal-separator"><hr></span><q>42a</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2ea</q><br><q>333</q><br><q>3e8</q><br><q>3e9</q><br><q>427</q><br><q>42f</q><br><span><var>HR</var><span class="hyp-type"><b>: </b><span>In y
  (qs_rec (filter (Nat.ltb p) l)
     (a (filter (Nat.ltb p) l)
        (qs_oblig (Nat.ltb p) p l)))</span></span></span><br></div><label class="goal-separator"><hr></label><q>42a</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="mi">2</span>: <span class="nb">apply</span> qs_filter_In, Nat.ltb_lt <span class="kr">in</span> HR.</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>432</q><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>2ea</q><br><q>333</q><br><q>3e8</q><br><q>3e9</q><br><q>427</q><br><q>42f</q><br><span><var>HR</var><span class="hyp-type"><b>: </b><span>p &lt; y</span></span></span><br></div><label class="goal-separator"><hr></label><q>42a</q></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><!-- TODO: can/should I hide the proofs of the helper lemmas? -->
</section>
<section id="conclusion">
<h3>Conclusion</h3>
<p>We can define a wrapper function without the accessibility argument and gather our results in a single theorem.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">quicksort</span> <span class="nv">l</span> := qs_rec l (lt_len_wf l).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Theorem</span> <span class="nf">quicksort_ok</span> : <span class="kr">forall</span> <span class="nv">l</span>, <span class="kr">let</span> <span class="nv">s</span> := quicksort l <span class="kr">in</span>
                                 Permutation l s /\ Sorted s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">l</span> : list nat,
<span class="kr">let</span> <span class="nv">s</span> := quicksort l <span class="kr">in</span> Permutation l s /\ Sorted s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>440</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>333</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">Permutation l (quicksort l)</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>447</q><label class="goal-separator"><hr></label><div class="goal-conclusion">Sorted (quicksort l)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>446</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> qs_Permutation.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>447</q><span class="goal-separator"><hr></span><q>44b</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> qs_Sorted.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Let's briefly assess <a class="reference internal" href="#leroy-s-criteria">Leroy's criteria</a> on our implementation and verification of quicksort.
Apart from the auxiliary accessibility arguments, the definition is highly readable.
Since these accessibility arguments disappear during extraction (below), the code is arguably even easier to read.
To prove properties, there seems to be a standard design pattern, outlined in our guide. Specifically, by deriving well-foundedness using <code class="highlight coq"><span class="n">well_founded_ltof</span></code> and adding the obligations to a hint database, we can focus on the main correctness arguments.
Lastly, no axioms were used.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Recursive Extraction</span> quicksort.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">
type bool =
| <span class="kt">True</span>
| <span class="kt">False</span>

type nat =
| O
| S of nat

type &#39;a list =
| Nil
| Cons of &#39;a * &#39;a list

<span class="sd">(** val app : &#39;a1 list -&gt; &#39;a1 list -&gt; &#39;a1 list **)</span>

<span class="kr">let rec</span> <span class="nv">app</span> <span class="nv">l</span> <span class="nv">m</span> =
  <span class="kr">match</span> l <span class="kr">with</span>
  | Nil -&gt; m
  | Cons (a, l1) -&gt; Cons (a, (app l1 m))

module Nat =
 <span class="kr">struct</span>
  <span class="sd">(** val leb : nat -&gt; nat -&gt; bool **)</span>

  <span class="kr">let rec</span> <span class="nv">leb</span> <span class="nv">n</span> <span class="nv">m</span> =
    <span class="kr">match</span> n <span class="kr">with</span>
    | O -&gt; <span class="kt">True</span>
    | S n&#39; -&gt; (<span class="kr">match</span> m <span class="kr">with</span>
               | O -&gt; <span class="kt">False</span>
               | S m&#39; -&gt; leb n&#39; m&#39;)

  <span class="sd">(** val ltb : nat -&gt; nat -&gt; bool **)</span>

  <span class="kr">let</span> <span class="nv">ltb</span> <span class="nv">n</span> <span class="nv">m</span> =
    leb (S n) m
 <span class="kr">end</span>

<span class="sd">(** val filter : (&#39;a1 -&gt; bool) -&gt; &#39;a1 list -&gt; &#39;a1 list **)</span>

<span class="kr">let rec</span> <span class="nv">filter</span> <span class="nv">f</span> = function
| Nil -&gt; Nil
| Cons (x, l0) -&gt;
  (<span class="kr">match</span> f x <span class="kr">with</span>
   | <span class="kt">True</span> -&gt; Cons (x, (filter f l0))
   | <span class="kt">False</span> -&gt; filter f l0)

<span class="sd">(** val geb : nat -&gt; nat -&gt; bool **)</span>

<span class="kr">let</span> <span class="nv">geb</span> <span class="nv">x</span> <span class="nv">y</span> =
  Nat.leb y x

<span class="sd">(** val qs_rec : nat list -&gt; nat list **)</span>

<span class="kr">let rec</span> <span class="nv">qs_rec</span> = function
| Nil -&gt; Nil
| Cons (x, xs) -&gt;
  <span class="kr">let</span> <span class="nv">l0</span> = filter (geb x) xs <span class="kr">in</span>
  <span class="kr">let</span> <span class="nv">r</span> = filter (Nat.ltb x) xs <span class="kr">in</span> app (qs_rec l0) (Cons (x, (qs_rec r)))

<span class="sd">(** val quicksort : nat list -&gt; nat list **)</span>

<span class="kr">let</span> <span class="nv">quicksort</span> =
  qs_rec
</blockquote></div></div></small></span></pre><p>In summary, Acc-recursion proves effective for implementing and verifying quicksort.
In the next section, we test whether Acc-recursion extends to other algorithms.</p>
</section>
</section>
<section id="rebalancing-binary-search-trees">
<h2>Rebalancing binary search trees</h2>
<p><em>Binary search trees</em> (BSTs) are most efficient when their height is minimal.
While <em>self-balancing BSTs</em> maintain a low height during updates, they are intricate.
A simpler alternative is to periodically rebalance the entire tree.
A time-optimal in-place algorithm for this was proposed by <a class="reference internal" href="#stout-and-warren-1986">Stout and Warren (1986)</a>, building on earlier work by Day (1976).
It is known as the <em>Day‚ÄìStout‚ÄìWarren</em> (DSW) algorithm.</p>
<p>The DSW algorithm consists of two phases.
First, the BST is flattened into a <em>vine</em>, where each parent node only has a right child.
Then, the vine is transformed into a balanced tree.
In this section, we will only examine the first phase, since the second phase is structurally recursive and hence not relevant to this tutorial.</p>
<!-- TODO: link to complete proof -->
<p>It should be noted that, as a functional programming language, Rocq does not benefit from the algorithm's in-placeness. That is, in the worst case, our implementation requires more than <span class="math">\(O(1)\)</span> additional space.
Nevertheless, it is worthwhile to verify the correctness of the algorithm.
Moreover, the first phase is particularly relevant for this tutorial, since it uses a specialized relation to prove termination.</p>
<!-- Also, although the DSW algorithm is not particularly useful in practice, it is an illustrative example of tree rotations. -->
<p>In the next section, we will first define binary search trees.
Then, we will implement the first phase of the DSW algorithm, appropriately called <code class="highlight coq"><span class="n">tree_to_vine</span></code>.
Lastly, we will prove that <code class="highlight coq"><span class="n">tree_to_vine</span></code> is correct.</p>
<section id="binary-search-trees">
<h3>Binary search trees</h3>
<p>A BST is a binary tree that satisfies the following invariant: for any node with key <span class="math">\(v\)</span>, all keys in the left subtree are less than <span class="math">\(v\)</span>, and all keys in the right subtree are greater than <span class="math">\(v\)</span>.
First, we define binary trees:</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">tree</span> : <span class="kt">Type</span> :=
  | E
  | T (l : tree) (v : nat) (r : tree).</span></span></pre><p>Next, we formalize the invariant.
A definition is given in <a class="reference external" href="https://softwarefoundations.cis.upenn.edu/vfa-current/SearchTree.html#BST">Software Foundations</a>, but instead of <code class="highlight coq"><span class="kn">Inductive</span></code>, we will define it as a predicate.
This definition enables more effective use of the powerful <code class="highlight coq"><span class="nb">firstorder</span></code> tactic, simplifying our proofs.
This is aptly illustrated by the succinct proof of <code class="highlight coq"><span class="n">forall_tree_mono</span></code>, a lemma we will need later.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">forall_tree</span> (<span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : tree) : <span class="kt">Prop</span> :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | E       =&gt; <span class="kt">True</span>
  | T l v r =&gt; P v /\ forall_tree P l /\ forall_tree P r
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">forall_tree_mono</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">Q</span> <span class="nv">t</span>,
  (<span class="kr">forall</span> <span class="nv">x</span>, P x -&gt; Q x) -&gt;
  forall_tree P t -&gt;
  forall_tree Q t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">P</span> <span class="nv">Q</span> : nat -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : tree),
(<span class="kr">forall</span> <span class="nv">x</span> : nat, P x -&gt; Q x) -&gt;
forall_tree P t -&gt; forall_tree Q t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>453</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">induction</span> t;
  <span class="nb">firstorder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">bst</span> (<span class="nv">t</span> : tree) : <span class="kt">Prop</span> :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | E       =&gt; <span class="kt">True</span>
  | T l v r =&gt; forall_tree (gt v) l /\ bst l
            /\ forall_tree (lt v) r /\ bst r
  <span class="kr">end</span>.</span></span></pre><p>For simplicity, as with quicksort, we assume that the key is a natural number (and there is no separate value).
Furthermore, <code class="highlight coq"><span class="n">gt</span></code> and <code class="highlight coq"><span class="n">lt</span></code> are strict, so we disallow duplicate keys.</p>
<!-- Assuming we generalize the type of the key, separate values could be simulated by tupling, where the value is ignored by the relation. A similar technique can be used to add a count, allowing duplicates. -->
</section>
<section id="implementation-of-tree-to-vine">
<h3>Implementation of <code class="highlight coq"><span class="n">tree_to_vine</span></code></h3>
<p>Now, we implement the first phase of the DSW algorithm, <code class="highlight coq"><span class="n">tree_to_vine</span></code>.
The naive definition is given below.
Broadly speaking, we traverse down the right <em>spine</em>, and whenever the left subtree is not empty, we <em>rotate</em> one node onto the spine.
This is visualized in the following figure.
For full details, refer to the original paper.</p>
<img alt="A (right) rotation in a graph" src="rotate.svg" style="width: 600px;" />
<p>As an aside, note how elegant the functional definition of a rotation is compared to the imperative implementation in the paper.
Essentially, only the parentheses are rearranged, so we can see at a glance that the ordering is correct.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Fail</span> <span class="kn">Fixpoint</span> <span class="nf">tree_to_vine</span> (<span class="nv">t</span> : tree) : tree :=
  <span class="kr">match</span> t <span class="kr">with</span>
  <span class="c">(* base case: *)</span>
  | E                  =&gt; E
  <span class="c">(* move down: *)</span>
  | T E v r            =&gt; T E v (tree_to_vine r)
  <span class="c">(* rotate: *)</span>
  | T (T t1 a t2) b t3 =&gt; tree_to_vine (T t1 a (T t2 b t3))
  <span class="kr">end</span>.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The command has indeed failed <span class="kr">with</span> message:
Recursive definition of tree_to_vine <span class="kr">is</span> ill-formed.
In environment
tree_to_vine : tree -&gt; tree
t : tree
l : tree
b : nat
t3 : tree
t1 : tree
a : nat
t2 : tree
Recursive call to tree_to_vine has principal argument
equal to <span class="s2">&quot;T t1 a (T t2 b t3)&quot;</span> instead of
one of the following variables: <span class="s2">&quot;l&quot;</span> <span class="s2">&quot;t3&quot;</span> <span class="s2">&quot;t1&quot;</span>
<span class="s2">&quot;t2&quot;</span>.
Recursive definition <span class="kr">is</span>:
<span class="s2">&quot;fun t : tree =&gt;</span>
<span class="s2"> match t with</span>
<span class="s2"> | E =&gt; E</span>
<span class="s2"> | T E b t3 =&gt; T E b (tree_to_vine t3)</span>
<span class="s2"> | T (T t1 a t2) b t3 =&gt;</span>
<span class="s2">     tree_to_vine (T t1 a (T t2 b t3))</span>
<span class="s2"> end&quot;</span>.</blockquote></div></div></small></span></pre><p>In the third case, we recur on a tree that is not a subterm of <code class="highlight coq"><span class="n">t</span></code>, so Rocq rejects the definition.
In fact, it is non-trivial to see why <code class="highlight coq"><span class="n">tree_to_vine</span></code> terminates.
The key observation is that the number of nodes in left subtrees 'hanging' from the spine decreases each recursive call. Here, we include leaves in the count.
This is formalized by <code class="highlight coq"><span class="n">size_left</span></code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">size</span> (<span class="nv">t</span> : tree) : nat := <span class="mi">1</span> +
  <span class="kr">match</span> t <span class="kr">with</span>
  | E       =&gt; <span class="mi">0</span>
  | T l _ r =&gt; size l + size r
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">size_left</span> (<span class="nv">t</span> : tree) : nat :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | E       =&gt; <span class="mi">0</span>
  | T l _ r =&gt; size l + size_left r
  <span class="kr">end</span>.</span></span></pre><p>In other words, <code class="highlight coq"><span class="n">size_left</span> <span class="n">t</span></code> decreases each recursive call.
Similarly to quicksort, we define a relation based on <code class="highlight coq"><span class="n">size_left</span></code> (and derive the well-foundedness and induction principle).
Then, following our <a class="reference internal" href="#guide-to-acc-recursion">guide</a>, we add auxiliary arguments to <code class="highlight coq"><span class="n">tree_to_vine</span></code> and prove the obligations as separate lemmas.
There are two distinct obligations this time, but <code class="highlight coq"><span class="kn">Hint Unfold</span> <span class="n">lt_size_left</span></code> is sufficient to automatically solve the first one.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">lt_size_left</span>     := ltof              _ size_left.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">lt_size_left_wf</span>  := well_founded_ltof _ size_left.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">wf_ind_size_left</span> := well_founded_induction lt_size_left_wf.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Fact</span> <span class="nf">tree_to_vine_oblig2</span> : <span class="kr">forall</span> <span class="nv">t1</span> <span class="nv">a</span> <span class="nv">t2</span> <span class="nv">b</span> <span class="nv">t3</span>,
  size_left (T t1 a (T t2 b t3)) &lt; size_left (T (T t1 a t2) b t3).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t1</span> : tree) (<span class="nv">a</span> : nat) (<span class="nv">t2</span> : tree) (<span class="nv">b</span> : nat)
  (<span class="nv">t3</span> : tree),
size_left (T t1 a (T t2 b t3)) &lt;
size_left (T (T t1 a t2) b t3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>459</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>t1</var><span class="hyp-type"><b>: </b><span>tree</span></span></span><br><q>d4</q><br><span><var>t2</var><span class="hyp-type"><b>: </b><span>tree</span></span></span><br><q>60</q><br><span><var>t3</var><span class="hyp-type"><b>: </b><span>tree</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">size_left (T t1 a (T t2 b t3)) &lt;
size_left (T (T t1 a t2) b t3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>460</q><span class="goal-separator"><hr></span><div class="goal-conclusion">size t1 + (size t2 + size_left t3) &lt;
S (size t1 + size t2 + size_left t3)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="bp">lia</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hint Unfold</span> lt_size_left : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Hint Resolve</span> tree_to_vine_oblig2 : core.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Program Fixpoint</span> <span class="nf">tree_to_vine</span> (<span class="nv">t</span> : tree) (<span class="nv">ACC</span> : Acc lt_size_left t) :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | E =&gt; E
  | T E v r =&gt;
      T E v (tree_to_vine r (Acc_inv ACC _))
  | T (T t1 a t2) b t3 =&gt;
      tree_to_vine (T t1 a (T t2 b t3)) (Acc_inv ACC _)
  <span class="kr">end</span>.</span></span></pre><p>Previously, we used <code class="highlight coq"><span class="n">lt</span></code> and <code class="highlight coq"><span class="n">lt_len</span></code> as relations, which are natural choices to compare natural numbers and lists, respectively.
On the other hand, <code class="highlight coq"><span class="n">tree_to_vine</span></code> is an example of where we need a relation tailored to the algorithm.</p>
<!-- In particular, `size` as a relation would not work to show termination! -->
<!-- You can extract `tree_to_vine` and check that the code is readable. -->
</section>
<section id="verification-of-tree-to-vine">
<h3>Verification of <code class="highlight coq"><span class="n">tree_to_vine</span></code></h3>
<p>Now, we will prove some properties of <code class="highlight coq"><span class="n">tree_to_vine</span></code>, following our guide.
We should prove that the resulting tree is a vine and contains the same elements, similarly to quicksort.
First, we establish some supporting lemmas.
The first one, <code class="highlight coq"><span class="n">forall_tree_to_vine</span></code>, demonstrates the proof strategy that we will repeatedly use.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">forall_tree_to_vine</span> : <span class="kr">forall</span> <span class="nv">P</span> <span class="nv">t</span> <span class="nv">ACC</span>,
  forall_tree P t -&gt; forall_tree P (tree_to_vine t ACC).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">P</span> : nat -&gt; <span class="kt">Prop</span>) (<span class="nv">t</span> : tree)
  (<span class="nv">ACC</span> : Acc lt_size_left t),
forall_tree P t -&gt; forall_tree P (tree_to_vine t ACC)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>46a</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">induction</span> t <span class="kr">as</span> [t IH] <span class="nb">using</span> wf_ind_size_left.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>3e</q><br><span><var>t</var><span class="hyp-type"><b>: </b><span>tree</span></span></span><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : tree,
ltof tree size_left y t -&gt;
<span class="kr">forall</span> <span class="nv">ACC</span> : Acc lt_size_left y,
forall_tree P y -&gt;
forall_tree P (tree_to_vine y ACC)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ACC</span> : Acc lt_size_left t,
forall_tree P t -&gt; forall_tree P (tree_to_vine t ACC)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">destruct</span> ACC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>3e</q><br><q>472</q><br><q>473</q><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : tree,
lt_size_left y t -&gt; Acc lt_size_left y</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forall_tree P t -&gt;
forall_tree P (tree_to_vine t (Acc_intro t a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>3e</q><br><q>472</q><br><q>473</q><br><q>479</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span>forall_tree P t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forall_tree P (tree_to_vine t (Acc_intro t a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">destruct</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>3e</q><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : tree,
ltof tree size_left y E -&gt;
<span class="kr">forall</span> <span class="nv">ACC</span> : Acc lt_size_left y,
forall_tree P y -&gt;
forall_tree P (tree_to_vine y ACC)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : tree,
lt_size_left y E -&gt; Acc lt_size_left y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>forall_tree P E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forall_tree P (tree_to_vine E (Acc_intro E a))</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>3e</q><br><q>461</q><br><span><var>v</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><q>462</q><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : tree,
ltof tree size_left y (T t1 v t2) -&gt;
<span class="kr">forall</span> <span class="nv">ACC</span> : Acc lt_size_left y,
forall_tree P y -&gt;
forall_tree P (tree_to_vine y ACC)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : tree,
lt_size_left y (T t1 v t2) -&gt; Acc lt_size_left y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>forall_tree P (T t1 v t2)</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">forall_tree P
  (tree_to_vine (T t1 v t2) (Acc_intro (T t1 v t2) a))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="mi">2</span>: <span class="nb">destruct</span> t1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>483</q><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>3e</q><br><q>48c</q><br><q>462</q><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : tree,
ltof tree size_left y (T E v t2) -&gt;
<span class="kr">forall</span> <span class="nv">ACC</span> : Acc lt_size_left y,
forall_tree P y -&gt;
forall_tree P (tree_to_vine y ACC)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : tree,
lt_size_left y (T E v t2) -&gt; Acc lt_size_left y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>forall_tree P (T E v t2)</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">forall_tree P
  (tree_to_vine (T E v t2) (Acc_intro (T E v t2) a))</div></blockquote><blockquote class="alectryon-goal"><div class="goal-hyps"><q>3e</q><br><span><var>t1_1</var><span class="hyp-type"><b>: </b><span>tree</span></span></span><br><span><var>v0</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>t1_2</var><span class="hyp-type"><b>: </b><span>tree</span></span></span><br><q>48c</q><br><q>462</q><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : tree,
ltof tree size_left y (T (T t1_1 v0 t1_2) v t2) -&gt;
<span class="kr">forall</span> <span class="nv">ACC</span> : Acc lt_size_left y,
forall_tree P y -&gt;
forall_tree P (tree_to_vine y ACC)</span></span></span><br><span><var>a</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : tree,
lt_size_left y (T (T t1_1 v0 t1_2) v t2) -&gt;
Acc lt_size_left y</span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>forall_tree P (T (T t1_1 v0 t1_2) v t2)</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">forall_tree P
  (tree_to_vine (T (T t1_1 v0 t1_2) v t2)
     (Acc_intro (T (T t1_1 v0 t1_2) v t2) a))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* Now, the three cases correspond to those in the definition! *)</span>
</span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="mi">3</span>: <span class="nb">simpl</span>; <span class="nb">apply</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>483</q><div class="alectryon-extra-goals"><q>494</q><blockquote class="alectryon-goal"><q>49b</q><label class="goal-separator"><hr></label><div class="goal-conclusion">ltof tree size_left (T t1_1 v0 (T t1_2 v t2))
  (T (T t1_1 v0 t1_2) v t2)</div></blockquote><blockquote class="alectryon-goal"><q>49b</q><label class="goal-separator"><hr></label><div class="goal-conclusion">forall_tree P (T t1_1 v0 (T t1_2 v t2))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">firstorder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">forall_tree_lt</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">t</span>,
  lt b a -&gt; forall_tree (lt a) t -&gt; forall_tree (lt b) t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : nat) (<span class="nv">t</span> : tree),
b &lt; a -&gt; forall_tree (lt a) t -&gt; forall_tree (lt b) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>4ab</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1ce</q><br><q>472</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span>b &lt; a</span></span></span><br><span><var>H0</var><span class="hyp-type"><b>: </b><span>forall_tree (lt a) t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">forall_tree (lt b) t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> forall_tree_mono <span class="kr">with</span> (lt a).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4b2</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">x</span> : nat, a &lt; x -&gt; b &lt; x</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>4b2</q><label class="goal-separator"><hr></label><div class="goal-conclusion">forall_tree (lt a) t</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="mi">1</span>: <span class="nb">transitivity</span> a.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>1ce</q><br><q>472</q><br><q>4b3</q><br><q>4b4</q><br><q>141</q><br><span><var>H1</var><span class="hyp-type"><b>: </b><span>a &lt; x</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">b &lt; a</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>4c0</q><label class="goal-separator"><hr></label><div class="goal-conclusion">a &lt; x</div></blockquote><q>4bb</q></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="bp">assumption</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">bst_rotate</span> : <span class="kr">forall</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">t1</span> <span class="nv">t2</span> <span class="nv">t3</span>,
  bst (T (T t1 a t2) b t3) -&gt; bst (T t1 a (T t2 b t3)).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">a</span> <span class="nv">b</span> : nat) (<span class="nv">t1</span> <span class="nv">t2</span> <span class="nv">t3</span> : tree),
bst (T (T t1 a t2) b t3) -&gt; bst (T t1 a (T t2 b t3))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>4c7</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">firstorder using</span> forall_tree_lt.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>We define the <code class="highlight coq"><span class="n">vine</span></code> predicate as a special case of <code class="highlight coq"><span class="n">bst</span></code> where all left children are <code class="highlight coq"><span class="n">E</span></code>. Note that a vine is isomorphic to a sorted list.
Then, we prove that <code class="highlight coq"><span class="n">tree_to_vine</span></code> outputs a <code class="highlight coq"><span class="n">vine</span></code>.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">vine</span> (<span class="nv">t</span> : tree) : <span class="kt">Prop</span> :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | E       =&gt; <span class="kt">True</span>
  | T E v r =&gt; forall_tree (lt v) r /\ vine r
  | _       =&gt; <span class="kt">False</span>
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">tree_to_vine_shape</span> : <span class="kr">forall</span> <span class="nv">t</span> <span class="nv">ACC</span>,
  bst t -&gt; vine (tree_to_vine t ACC).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">t</span> : tree) (<span class="nv">ACC</span> : Acc lt_size_left t),
bst t -&gt; vine (tree_to_vine t ACC)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>4cc</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">induction</span> t <span class="kr">as</span> [t IH] <span class="nb">using</span> wf_ind_size_left.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>472</q><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : tree,
ltof tree size_left y t -&gt;
<span class="kr">forall</span> <span class="nv">ACC</span> : Acc lt_size_left y,
bst y -&gt; vine (tree_to_vine y ACC)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">ACC</span> : Acc lt_size_left t,
bst t -&gt; vine (tree_to_vine t ACC)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">destruct</span> ACC.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>472</q><br><q>4d4</q><br><q>479</q><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">bst t -&gt; vine (tree_to_vine t (Acc_intro t a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>472</q><br><q>4d4</q><br><q>479</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bst t</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">vine (tree_to_vine t (Acc_intro t a))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">destruct</span> t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : tree,
ltof tree size_left y E -&gt;
<span class="kr">forall</span> <span class="nv">ACC</span> : Acc lt_size_left y,
bst y -&gt; vine (tree_to_vine y ACC)</span></span></span><br><q>486</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bst E</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">vine (tree_to_vine E (Acc_intro E a))</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>461</q><br><q>48c</q><br><q>462</q><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : tree,
ltof tree size_left y (T t1 v t2) -&gt;
<span class="kr">forall</span> <span class="nv">ACC</span> : Acc lt_size_left y,
bst y -&gt; vine (tree_to_vine y ACC)</span></span></span><br><q>48e</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bst (T t1 v t2)</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">vine
  (tree_to_vine (T t1 v t2) (Acc_intro (T t1 v t2) a))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="mi">2</span>: <span class="nb">destruct</span> t1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>4e3</q><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><q>48c</q><br><q>462</q><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : tree,
ltof tree size_left y (T E v t2) -&gt;
<span class="kr">forall</span> <span class="nv">ACC</span> : Acc lt_size_left y,
bst y -&gt; vine (tree_to_vine y ACC)</span></span></span><br><q>497</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bst (T E v t2)</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">vine
  (tree_to_vine (T E v t2) (Acc_intro (T E v t2) a))</div></blockquote><blockquote class="alectryon-goal"><div class="goal-hyps"><q>49c</q><br><q>49d</q><br><q>49e</q><br><q>48c</q><br><q>462</q><br><span><var>IH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">y</span> : tree,
ltof tree size_left y (T (T t1_1 v0 t1_2) v t2) -&gt;
<span class="kr">forall</span> <span class="nv">ACC</span> : Acc lt_size_left y,
bst y -&gt; vine (tree_to_vine y ACC)</span></span></span><br><q>4a0</q><br><span><var>H</var><span class="hyp-type"><b>: </b><span>bst (T (T t1_1 v0 t1_2) v t2)</span></span></span><br></div><label class="goal-separator"><hr></label><div class="goal-conclusion">vine
  (tree_to_vine (T (T t1_1 v0 t1_2) v t2)
     (Acc_intro (T (T t1_1 v0 t1_2) v t2) a))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kp">all</span>: <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4e4</q><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kt">True</span></div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>4f2</q><label class="goal-separator"><hr></label><div class="goal-conclusion">forall_tree (lt v)
  (tree_to_vine t2 (a t2 (le_n (S (size_left t2))))) /\
vine
  (tree_to_vine t2 (a t2 (le_n (S (size_left t2)))))</div></blockquote><blockquote class="alectryon-goal"><q>4f7</q><label class="goal-separator"><hr></label><div class="goal-conclusion">vine
  (tree_to_vine (T t1_1 v0 (T t1_2 v t2))
     (a (T t1_1 v0 (T t1_2 v t2))
        (tree_to_vine_oblig2 t1_1 v0 t1_2 v t2)))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>4fd</q></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">trivial</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4f2</q><span class="goal-separator"><hr></span><q>501</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">split</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4f2</q><span class="goal-separator"><hr></span><div class="goal-conclusion">forall_tree (lt v)
  (tree_to_vine t2 (a t2 (le_n (S (size_left t2)))))</div></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>4f2</q><label class="goal-separator"><hr></label><div class="goal-conclusion">vine
  (tree_to_vine t2 (a t2 (le_n (S (size_left t2)))))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="mi">1</span>: <span class="nb">apply</span> forall_tree_to_vine.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4f2</q><span class="goal-separator"><hr></span><div class="goal-conclusion">forall_tree (lt v) t2</div></blockquote><q>50d</q></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="mi">2</span>: <span class="nb">apply</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>512</q><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>4f2</q><label class="goal-separator"><hr></label><div class="goal-conclusion">ltof tree size_left t2 (T E v t2)</div></blockquote><blockquote class="alectryon-goal"><q>4f2</q><label class="goal-separator"><hr></label><div class="goal-conclusion">bst t2</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">firstorder</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><label class="alectryon-input">-</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4f7</q><span class="goal-separator"><hr></span><q>503</q></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="nb">apply</span> IH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><q>4f7</q><span class="goal-separator"><hr></span><q>4a7</q></blockquote><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>4f7</q><label class="goal-separator"><hr></label><div class="goal-conclusion">bst (T t1_1 v0 (T t1_2 v t2))</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><label class="alectryon-input"><span class="mi">2</span>: <span class="nb">apply</span> bst_rotate.</label><small class="alectryon-output"><div><div class="alectryon-goals"><q>520</q><div class="alectryon-extra-goals"><blockquote class="alectryon-goal"><q>4f7</q><label class="goal-separator"><hr></label><div class="goal-conclusion">bst (T (T t1_1 v0 t1_2) v t2)</div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kp">all</span>: <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre><p>Next, we want to prove that the output vine contains the same elements as the input tree.
Since all keys are unique, it is sufficient to show shared membership through <code class="highlight coq"><span class="n">contains</span></code>.
The proof is left as an exercise to the reader.
Note that the condition <code class="highlight coq"><span class="n">bst</span> <span class="n">t</span></code> is not necessary.</p>
<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Fixpoint</span> <span class="nf">contains</span> (<span class="nv">x</span> : nat) (<span class="nv">t</span> : tree) : <span class="kt">Prop</span> :=
  <span class="kr">match</span> t <span class="kr">with</span>
  | E       =&gt; <span class="kt">False</span>
  | T l v r =&gt; x = v \/ contains x l \/ contains x r
  <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Lemma</span> <span class="nf">tree_to_vine_contains</span> : <span class="kr">forall</span> <span class="nv">x</span> <span class="nv">t</span> <span class="nv">ACC</span>,
  contains x t &lt;-&gt; contains x (tree_to_vine t ACC).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">x</span> : nat) (<span class="nv">t</span> : tree) (<span class="nv">ACC</span> : Acc lt_size_left t),
contains x t &lt;-&gt; contains x (tree_to_vine t ACC)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><label class="alectryon-input"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><q>52a</q></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  <span class="c">(* exercise *)</span>
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Admitted</span>.</span></span></pre><p>The combination of <code class="highlight coq"><span class="n">tree_to_vine_shape</span></code> and <code class="highlight coq"><span class="n">tree_to_vine_contains</span></code> verifies <code class="highlight coq"><span class="n">tree_to_vine</span></code>.
This is only a small part of the overall correctness proof of the DSW algorithm.</p>
</section>
</section>
<section id="conclusion-1">
<h2>Conclusion</h2>
<p>We introduced and proved the well-founded induction principle.
Then, we compared Function, Equations, Program Fixpoint, and Acc-recursion as techniques to perform well-founded recursion. We found that Acc-recursion is best if code extraction is important, and otherwise Equations is a good option.
We presented a practical guide on Acc-recursion and used it to verify a non-trivial algorithm: quicksort.
We further experimented with Acc-recursion on a tree rebalancing algorithm that requires a specialized relation to prove termination.</p>
<p><strong>Acknowledgments.</strong>
This tutorial was developed as part of a research internship at Eindhoven University of Technology.
Thanks to <a class="reference external" href="https://www.cs.ru.nl/~herman/">Herman Geuvers</a> for his guidance in shaping the project and his enthusiastic supervision.</p>
<!-- TODO: some definitions are structurally recursive in more than more argument! -->
<!-- TODO: fuel? -->
<!-- TODO: check if I consistently include types or not -->
<!-- TODO: wf_ind naming scheme? -->
</section>
<section id="references">
<h2>References</h2>
<p id="leroy-2024">Xavier Leroy. &quot;Well-founded recursion done right&quot;. In: <em>The Tenth International Workshop on Coq for Programming Languages</em>. Jan. 2024. URL: <a class="reference external" href="https://popl24.sigplan.org/details/CoqPL-2024-papers/2/Well-founded-recursion-done-right">https://popl24.sigplan.org/details/CoqPL-2024-papers/2/Well-founded-recursion-done-right</a>.</p>
<p id="sozeau-and-mangin-2019">Matthieu Sozeau and Cyprien Mangin. &quot;Equations reloaded: high-level dependently-typed functional programming and proving in Coq&quot;. In: <em>Proceedings of the ACM on Programming Languages</em> 3.ICFP (July 2019), pp. 1‚Äì29. DOI: <a class="reference external" href="https://doi.org/10.1145/3341690">10.1145/3341690</a>.</p>
<p id="stout-and-warren-1986">Quentin F. Stout and Bette L. Warren. &quot;Tree rebalancing in optimal time and space&quot;. In: <em>Communications of the ACM</em> 29.9 (Sept. 1986), pp. 902‚Äì908. DOI: <a class="reference external" href="https://doi.org/10.1145/6592.6599">10.1145/6592.6599</a>.</p>
</section>
</main>
</div></body>
</html>
